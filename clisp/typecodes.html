<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>35.3. Object Pointer Representations</title><link rel="stylesheet" href="impnotes.css" type="text/css" /><link rev="made" href="mailto:clisp-list@lists.sourceforge.net" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot_7566" /><link rel="start" href="index.html" title="Implementation Notes for GNU CLISP" /><link rel="up" href="gc.html" title="Chapter 35. Overview of CLISP's Garbage Collection" /><link rel="prev" href="lisp-obj-in-c.html" title="35.2. Lisp objects in CLISP" /><link rel="next" href="memory-models.html" title="35.4. Memory Models" /><link rel="copyright" href="legalese.html" title="Legal Status of the CLISP Implementation Notes" /><meta name="date" content="'generated: 2008-07-02 11:52:30-04:00'" /><link rel="author" title="Authors" href="index.html#authors" /><link rel="contents" title="Table of Contents" href="index.html" /><link rel="glossary" href="glossary.html" /><link rel="help" href="faq.html#faq-help" title="How do I ask for help?" /><link rel="home" title="Home" href="http://clisp.cons.org" /><link rel="index" href="idx.html" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">35.3. Object Pointer Representations</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="lisp-obj-in-c.html">Prev</a> </td><th width="60%" align="center">Chapter 35. Overview of <span class="command"><strong>CLISP</strong></span>'s Garbage Collection</th><td width="20%" align="right"> <a accesskey="n" href="memory-models.html">Next</a></td></tr></table><hr /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="typecodes"></a>35.3. Object Pointer Representations</h2></div></div></div><p><a class="ulink" href="http://clisp.cons.org" target="_top"><span class="command"><strong>CLISP</strong></span></a> implements two ways of representing object pointers.
(An object pointer, <a class="ulink" href="http://c-faq.com/" target="_top"><span class="command"><strong>C</strong></span></a> type <a class="link" href="typecodes.html" title="35.3. Object Pointer Representations"><span class="type">object</span></a>, contains a
pointer to the memory location of the object, or - for <a class="link" href="lisp-obj-in-c.html#immediate-o" title="Immediate objects">immediate object</a>
 - all bits of the object itself.)
Both of them have some things in common:
</p><div class="itemizedlist"><ul type="disc"><li>There is a distinction between <a class="link" href="lisp-obj-in-c.html#immediate-o" title="Immediate objects">immediate object</a>s
   (<a class="ulink" href="http://www.lisp.org/HyperSpec/Body/syscla_character.html" target="_top"><code class="classname">CHARACTER</code></a>s, <a class="ulink" href="http://www.lisp.org/HyperSpec/Body/typ_fixnum.html" target="_top"><code class="classname">FIXNUM</code></a>s, <a class="ulink" href="http://www.lisp.org/HyperSpec/Body/typ_short-flo_m_long-float.html" target="_top"><code class="classname">SHORT-FLOAT</code></a>s, etc) and
   heap allocated objects.</li><li>All object pointers are typed, i.e. contain a few
   bits of information about the type of the pointed-to object. At a
   minimum, these bits must allow to distinguish immediate and
   heap-allocated objects.</li><li>Not all of the type information is contained in the
   object pointer.  For example, <a class="clhs" href="http://www.lisp.org/HyperSpec/Body/chap-7.html"><span class="command"><strong>CLOS</strong></span></a> objects can change their type
   when <a class="ulink" href="http://www.lisp.org/HyperSpec/Body/stagenfun_change-class.html" target="_top"><code class="function">CHANGE-CLASS</code></a> is called. To avoid scanning all the heap for
   references when this happens, the class information is stored in the
   heap allocated object, not in the object pointer.</li></ul></div><p>The <a class="link" href="typecodes.html" title="35.3. Object Pointer Representations"><span class="strong"><strong><code class="option">HEAPCODES</code></strong></span></a> object representation has a minimum of type
bits in the object pointer, namely, 2 bits. They allow to distinguish
<a class="link" href="lisp-obj-in-c.html#immediate-o" title="Immediate objects">immediate object</a>s (which have some more type bits), <a class="ulink" href="http://www.lisp.org/HyperSpec/Body/syscla_cons.html" target="_top"><code class="classname">CONS</code></a>es (which
have no type bits in the heap, since they occupy just two words in the
heap, with no header), other heap objects (many, from <a class="ulink" href="http://www.lisp.org/HyperSpec/Body/typ_simple-vector.html" target="_top"><code class="classname">SIMPLE-VECTOR</code></a>s
to <a class="link" href="dffi.html#fptr"><code class="classname">FFI:FOREIGN-POINTER</code></a>s), and <span class="type">Subr</span>s. Most object types are
distinguished by looking a the <em class="structfield"><code>rectype</code></em> field
in the header of the heap object.</p><p>The <a class="link" href="typecodes.html" title="35.3. Object Pointer Representations"><span class="strong"><strong><code class="option">TYPECODES</code></strong></span></a> object representation has about two dozen of types
encoded in 6 or 7 bits in the object pointer.
Typically these are the upper 8 bits of a word (on a 32-bit machine) or
the upper 16 bits or 32 bits of a word (on a 64-bit machine).
The particular values of the typecodes allow many common operations to
be performed with a single bit test (e.g. <a class="ulink" href="http://www.lisp.org/HyperSpec/Body/fun_consp.html" target="_top"><code class="function">CONSP</code></a> and <a class="ulink" href="http://www.lisp.org/HyperSpec/Body/fun_minuspcm_plusp.html" target="_top"><code class="function">MINUSP</code></a> for a
<a class="ulink" href="http://www.lisp.org/HyperSpec/Body/syscla_real.html" target="_top"><code class="classname">REAL</code></a> are bit tests) or range check.
However, the <em class="structfield"><code>rectype</code></em> field still exists for
many types, because there are many built-in types which do not need a
particularly fast type test.</p><p>Which object representation is chosen is decided at build time
depending on the available preprocessor definitions. You can define
<a class="link" href="typecodes.html" title="35.3. Object Pointer Representations"><span class="strong"><strong><code class="option">TYPECODES</code></strong></span></a> or <a class="link" href="typecodes.html" title="35.3. Object Pointer Representations"><span class="strong"><strong><code class="option">HEAPCODES</code></strong></span></a> to force one or the other.</p><p>One might expect that <a class="link" href="typecodes.html" title="35.3. Object Pointer Representations"><span class="strong"><strong><code class="option">TYPECODES</code></strong></span></a> is faster than <a class="link" href="typecodes.html" title="35.3. Object Pointer Representations"><span class="strong"><strong><code class="option">HEAPCODES</code></strong></span></a>
because it does not need to make as many memory accesses. This effect
is, however, hardly measurable in practice (certainly not more than 5%
faster).  Apparently because, first, the situations where the type of an
object is requested but then the object is not looked into are rare.
It is much more common to look into an object, regardless of its type.
Second, due to the existence of data caches in the CPU, accessing a heap
location twice, once for the type test and then immediately afterwards
for the data, is not significantly slower than just accessing the
data.</p><p><a class="link" href="typecodes.html" title="35.3. Object Pointer Representations"><span class="strong"><strong><code class="option">TYPECODES</code></strong></span></a> is problematic on 32-bit machines, when you want to
use more than 16 MB of memory, because the type bits (at bit 31..24)
interfere with the bits of a heap address. For this reason,
<a class="link" href="typecodes.html" title="35.3. Object Pointer Representations"><span class="strong"><strong><code class="option">HEAPCODES</code></strong></span></a> is the default on 32-bit platforms.</p><p><a class="link" href="typecodes.html" title="35.3. Object Pointer Representations"><span class="strong"><strong><code class="option">HEAPCODES</code></strong></span></a> is problematic on platforms whose object alignment
is less than 4. This affects only the mc680x0 CPU; however, here the
alignment can usually be guaranteed through some <a class="ulink" href="http://gcc.gnu.org/" target="_top"><span class="command"><strong>gcc</strong></span></a> options.</p></div><div class="bookinfo"><hr /><table width="100%" summary="impnotes meta info"><th><td align="left">These notes document <a class="ulink" href="http://clisp.cons.org" target="_top"><span class="command"><strong>CLISP</strong></span></a> version 2.46</td><td align="right">Last modified: 2008-07-02</td></th></table></div><div class="custom-footer"><hr /><table width="100%"><tr><td align="left"><a href="http://clisp.cons.org"><img src="clisp.png" width="48" height="48" alt="[CLISP home]" /></a></td><td align="center"><a href="http://sourceforge.net/donate/index.php?group_id=1355"><img src="http://images.sourceforge.net/images/project-support.jpg" width="88" height="32" alt="[Support CLISP]" /></a></td><td align="right"><a href="http://sourceforge.net"><img width="125" height="37" alt="[SourceForge]" src="http://sflogo.sourceforge.net/sflogo.php?group_id=1355&amp;type=2&amp;page=typecodes" /></a></td></tr></table></div><hr /><form method="get" action="http://www.google.com/custom" target="_top"><table width="100%" border="0"><tr><td nowrap="nowrap" align="center"><input type="hidden" name="domains" value="clisp.cons.org;clisp.podval.org;www.lisp.org" /><label for="sbi" style="display: none">Enter your search terms</label><input type="text" name="q" size="50" maxlength="255" id="sbi" value="35.3. Object Pointer Representations" /><label for="sbb" style="display: none">Submit search form</label><input type="submit" name="sa" value="Google Search" id="sbb" /></td></tr><tr><td nowrap="nowrap" align="center"><input type="radio" name="sitesearch" value="" checked="1" id="ss0" /><label for="ss0" title="Search the Web"><small>Web</small></label><input type="radio" name="sitesearch" value="clisp.cons.org" id="ss1" /><label for="ss1" title="Search clisp.cons.org"><small>clisp.cons.org</small></label><input type="radio" name="sitesearch" value="clisp.podval.org" id="ss2" /><label for="ss2" title="Search clisp.podval.org"><small>clisp.podval.org</small></label><input type="radio" name="sitesearch" value="www.lisp.org" id="ss3" /><label for="ss3" title="Search www.lisp.org"><small>www.lisp.org</small></label><input type="hidden" name="client" value="pub-4445255502750357" /><input type="hidden" name="forid" value="1" /><input type="hidden" name="ie" value="UTF-8" /><input type="hidden" name="oe" value="UTF-8" /><input type="hidden" name="cof" value="GALT:#008000;GL:1;DIV:#336699;VLC:663399;AH:center;BGC:FFFFFF;LBGC:000000;ALC:0000FF;LC:0000FF;T:000000;GFNT:0000FF;GIMP:0000FF;LH:48;LW:48;L:http://clisp.cons.org/clisp.png;S:http://clisp.cons.org;FORID:1" /><input type="hidden" name="hl" value="en" /></td></tr></table></form><hr /><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="lisp-obj-in-c.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="gc.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="memory-models.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">35.2. Lisp objects in <span class="command"><strong>CLISP</strong></span> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 35.4. Memory Models</td></tr></table></div></body></html>
