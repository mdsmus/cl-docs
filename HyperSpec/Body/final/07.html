<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content=
"HTML Tidy for Linux/x86 (vers 12 April 2005), see www.w3.org">
<title>CLHS: Chapter 7</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="m_loop_f.htm">
<link rel="UP" href="../Front/Contents.htm">
<link rel="NEXT" href="07_a.htm">
<title>CLHS: Section 7.1</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="07_.htm">
<link rel="UP" href="07_.htm">
<link rel="NEXT" href="07_aa.htm">
<title>CLHS: Section 7.1.1</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="07_a.htm">
<link rel="UP" href="07_a.htm">
<link rel="NEXT" href="07_ab.htm">
<title>CLHS: Section 7.1.2</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="07_aa.htm">
<link rel="UP" href="07_a.htm">
<link rel="NEXT" href="07_ac.htm">
<title>CLHS: Section 7.1.3</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="07_ab.htm">
<link rel="UP" href="07_a.htm">
<link rel="NEXT" href="07_ad.htm">
<title>CLHS: Section 7.1.4</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="07_ac.htm">
<link rel="UP" href="07_a.htm">
<link rel="NEXT" href="07_ae.htm">
<title>CLHS: Section 7.1.5</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="07_ad.htm">
<link rel="UP" href="07_a.htm">
<link rel="NEXT" href="07_af.htm">
<title>CLHS: Section 7.1.6</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="07_ae.htm">
<link rel="UP" href="07_a.htm">
<link rel="NEXT" href="07_ag.htm">
<title>CLHS: Section 7.1.7</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="07_af.htm">
<link rel="UP" href="07_a.htm">
<link rel="NEXT" href="07_b.htm">
<title>CLHS: Section 7.2</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="07_ag.htm">
<link rel="UP" href="07_.htm">
<link rel="NEXT" href="07_ba.htm">
<title>CLHS: Section 7.2.1</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="07_b.htm">
<link rel="UP" href="07_b.htm">
<link rel="NEXT" href="07_bb.htm">
<title>CLHS: Section 7.2.2</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="07_ba.htm">
<link rel="UP" href="07_b.htm">
<link rel="NEXT" href="07_bc.htm">
<title>CLHS: Section 7.2.3</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="07_bb.htm">
<link rel="UP" href="07_b.htm">
<link rel="NEXT" href="07_c.htm">
<title>CLHS: Section 7.3</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="07_bc.htm">
<link rel="UP" href="07_.htm">
<link rel="NEXT" href="07_ca.htm">
<title>CLHS: Section 7.3.1</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="07_c.htm">
<link rel="UP" href="07_c.htm">
<link rel="NEXT" href="07_d.htm">
<title>CLHS: Section 7.4</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="07_ca.htm">
<link rel="UP" href="07_.htm">
<link rel="NEXT" href="07_da.htm">
<title>CLHS: Section 7.4.1</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="07_d.htm">
<link rel="UP" href="07_d.htm">
<link rel="NEXT" href="07_e.htm">
<title>CLHS: Section 7.5</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="07_da.htm">
<link rel="UP" href="07_.htm">
<link rel="NEXT" href="07_ea.htm">
<title>CLHS: Section 7.5.1</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="07_e.htm">
<link rel="UP" href="07_e.htm">
<link rel="NEXT" href="07_eb.htm">
<title>CLHS: Section 7.5.2</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="07_ea.htm">
<link rel="UP" href="07_e.htm">
<link rel="NEXT" href="07_ec.htm">
<title>CLHS: Section 7.5.3</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="07_eb.htm">
<link rel="UP" href="07_e.htm">
<link rel="NEXT" href="07_f.htm">
<title>CLHS: Section 7.6</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="07_ec.htm">
<link rel="UP" href="07_.htm">
<link rel="NEXT" href="07_fa.htm">
<title>CLHS: Section 7.6.1</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="07_f.htm">
<link rel="UP" href="07_f.htm">
<link rel="NEXT" href="07_fb.htm">
<title>CLHS: Section 7.6.2</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="07_fa.htm">
<link rel="UP" href="07_f.htm">
<link rel="NEXT" href="07_fc.htm">
<title>CLHS: Section 7.6.3</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="07_fb.htm">
<link rel="UP" href="07_f.htm">
<link rel="NEXT" href="07_fd.htm">
<title>CLHS: Section 7.6.4</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="07_fc.htm">
<link rel="UP" href="07_f.htm">
<link rel="NEXT" href="07_fe.htm">
<title>CLHS: Section 7.6.5</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="07_fd.htm">
<link rel="UP" href="07_f.htm">
<link rel="NEXT" href="07_fea.htm">
<title>CLHS: Section 7.6.5.1</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="07_fe.htm">
<link rel="UP" href="07_fe.htm">
<link rel="NEXT" href="07_ff.htm">
<title>CLHS: Section 7.6.6</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="07_fea.htm">
<link rel="UP" href="07_f.htm">
<link rel="NEXT" href="07_ffa.htm">
<title>CLHS: Section 7.6.6.1</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="07_ff.htm">
<link rel="UP" href="07_ff.htm">
<link rel="NEXT" href="07_ffaa.htm">
<title>CLHS: Section 7.6.6.1.1</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="07_ffa.htm">
<link rel="UP" href="07_ffa.htm">
<link rel="NEXT" href="07_ffab.htm">
<title>CLHS: Section 7.6.6.1.2</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="07_ffaa.htm">
<link rel="UP" href="07_ffa.htm">
<link rel="NEXT" href="07_ffac.htm">
<title>CLHS: Section 7.6.6.1.3</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="07_ffab.htm">
<link rel="UP" href="07_ffa.htm">
<link rel="NEXT" href="07_ffb.htm">
<title>CLHS: Section 7.6.6.2</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="07_ffac.htm">
<link rel="UP" href="07_ff.htm">
<link rel="NEXT" href="07_ffc.htm">
<title>CLHS: Section 7.6.6.3</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="07_ffb.htm">
<link rel="UP" href="07_ff.htm">
<link rel="NEXT" href="07_ffd.htm">
<title>CLHS: Section 7.6.6.4</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="07_ffc.htm">
<link rel="UP" href="07_ff.htm">
<link rel="NEXT" href="07_fg.htm">
<title>CLHS: Section 7.6.7</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="07_ffd.htm">
<link rel="UP" href="07_f.htm">
<link rel="NEXT" href="c_object.htm">
</head>
<body>
<p><a name="chapseven" id="chapseven"></a><a name="objects" id=
"objects"></a></p>
<h2>7. Objects</h2>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>7.1 Object Creation and Initialization</h2>
<p>The <a rel="DEFINITION" href=
"26_glo_g.htm#generic_function"><i>generic function</i></a> <a rel=
"DEFINITION" href=
"f_mk_ins.htm#make-instance"><b>make-instance</b></a> creates and
returns a new <a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a> of a <a rel=
"DEFINITION" href="26_glo_c.htm#class"><i>class</i></a>. The first
argument is a <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a> or the <a rel="DEFINITION"
href="26_glo_n.htm#name"><i>name</i></a> of a <a rel="DEFINITION"
href="26_glo_c.htm#class"><i>class</i></a>, and the remaining
arguments form an <a rel="DEFINITION" href=
"26_glo_i.htm#initialization_argument_list"><i>initialization
argument list</i></a>.</p>
<p>The initialization of a new <a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a> consists of several
distinct steps, including the following: combining the explicitly
supplied initialization arguments with default values for the
unsupplied initialization arguments, checking the validity of the
initialization arguments, allocating storage for the <a rel=
"DEFINITION" href="26_glo_i.htm#instance"><i>instance</i></a>,
filling <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slots</i></a> with values, and executing
user-supplied <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>methods</i></a> that perform additional
initialization. Each step of <a rel="DEFINITION" href=
"f_mk_ins.htm#make-instance"><b>make-instance</b></a> is
implemented by a <a rel="DEFINITION" href=
"26_glo_g.htm#generic_function"><i>generic function</i></a> to
provide a mechanism for customizing that step. In addition, <a rel=
"DEFINITION" href=
"f_mk_ins.htm#make-instance"><b>make-instance</b></a> is itself a
<a rel="DEFINITION" href="26_glo_g.htm#generic_function"><i>generic
function</i></a> and thus also can be customized.</p>
<p>The object system specifies system-supplied primary <a rel=
"DEFINITION" href="26_glo_m.htm#method"><i>methods</i></a> for each
step and thus specifies a well-defined standard behavior for the
entire initialization process. The standard behavior provides four
simple mechanisms for controlling initialization:</p>
<dl>
<dt>* Declaring a <a rel="DEFINITION" href=
"26_glo_s.htm#symbol"><i>symbol</i></a> to be an initialization
argument for a <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a>. An initialization argument is
declared by using the <tt>:initarg</tt> slot option to <a rel=
"DEFINITION" href="m_defcla.htm#defclass"><b>defclass</b></a>. This
provides a mechanism for supplying a value for a <a rel=
"DEFINITION" href="26_glo_s.htm#slot"><i>slot</i></a> in a call to
<a rel="DEFINITION" href=
"f_mk_ins.htm#make-instance"><b>make-instance</b></a>.<br></dt>
<dt>* Supplying a default value form for an initialization
argument. Default value forms for initialization arguments are
defined by using the <tt>:default-initargs</tt> class option to
<a rel="DEFINITION" href=
"m_defcla.htm#defclass"><b>defclass</b></a>. If an initialization
argument is not explicitly provided as an argument to <a rel=
"DEFINITION" href=
"f_mk_ins.htm#make-instance"><b>make-instance</b></a>, the default
value form is evaluated in the lexical environment of the <a rel=
"DEFINITION" href="m_defcla.htm#defclass"><b>defclass</b></a> form
that defined it, and the resulting value is used as the value of
the initialization argument.<br></dt>
<dt>* Supplying a default initial value form for a <a rel=
"DEFINITION" href="26_glo_s.htm#slot"><i>slot</i></a>. A default
initial value form for a <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> is defined by using the
<tt>:initform</tt> slot option to <a rel="DEFINITION" href=
"m_defcla.htm#defclass"><b>defclass</b></a>. If no initialization
argument associated with that <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> is given as an argument to
<a rel="DEFINITION" href=
"f_mk_ins.htm#make-instance"><b>make-instance</b></a> or is
defaulted by <tt>:default-initargs</tt>, this default initial value
form is evaluated in the lexical environment of the <a rel=
"DEFINITION" href="m_defcla.htm#defclass"><b>defclass</b></a> form
that defined it, and the resulting value is stored in the <a rel=
"DEFINITION" href="26_glo_s.htm#slot"><i>slot</i></a>. The
<tt>:initform</tt> form for a <a rel="DEFINITION" href=
"26_glo_l.htm#local_slot"><i>local slot</i></a> may be used when
creating an <a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a>, when updating an
<a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a> to conform to a
redefined <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a>, or when updating an <a rel=
"DEFINITION" href="26_glo_i.htm#instance"><i>instance</i></a> to
conform to the definition of a different <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a>. The <tt>:initform</tt> form
for a <a rel="DEFINITION" href="26_glo_s.htm#shared_slot"><i>shared
slot</i></a> may be used when defining or re-defining the <a rel=
"DEFINITION" href="26_glo_c.htm#class"><i>class</i></a>.<br></dt>
<dt>* Defining <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>methods</i></a> for <a rel="DEFINITION"
href=
"f_init_i.htm#initialize-instance"><b>initialize-instance</b></a>
and <a rel="DEFINITION" href=
"f_shared.htm#shared-initialize"><b>shared-initialize</b></a>. The
slot-filling behavior described above is implemented by a
system-supplied primary <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>method</i></a> for <a rel="DEFINITION"
href=
"f_init_i.htm#initialize-instance"><b>initialize-instance</b></a>
which invokes <a rel="DEFINITION" href=
"f_shared.htm#shared-initialize"><b>shared-initialize</b></a>. The
<a rel="DEFINITION" href="26_glo_g.htm#generic_function"><i>generic
function</i></a> <a rel="DEFINITION" href=
"f_shared.htm#shared-initialize"><b>shared-initialize</b></a>
implements the parts of initialization shared by these four
situations: when making an <a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a>, when re-initializing
an <a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a>, when updating an
<a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a> to conform to a
redefined <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a>, and when updating an <a rel=
"DEFINITION" href="26_glo_i.htm#instance"><i>instance</i></a> to
conform to the definition of a different <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a>. The system-supplied primary
<a rel="DEFINITION" href="26_glo_m.htm#method"><i>method</i></a>
for <a rel="DEFINITION" href=
"f_shared.htm#shared-initialize"><b>shared-initialize</b></a>
directly implements the slot-filling behavior described above, and
<a rel="DEFINITION" href=
"f_init_i.htm#initialize-instance"><b>initialize-instance</b></a>
simply invokes <a rel="DEFINITION" href=
"f_shared.htm#shared-initialize"><b>shared-initialize</b></a>.<br></dt>
</dl>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>7.1.1 Initialization Arguments</h2>
<p>An initialization argument controls <a rel="DEFINITION" href=
"26_glo_o.htm#object"><i>object</i></a> creation and
initialization. It is often convenient to use keyword <a rel=
"DEFINITION" href="26_glo_s.htm#symbol"><i>symbols</i></a> to name
initialization arguments, but the <a rel="DEFINITION" href=
"26_glo_n.htm#name"><i>name</i></a> of an initialization argument
can be any <a rel="DEFINITION" href=
"26_glo_s.htm#symbol"><i>symbol</i></a>, including <a rel=
"DEFINITION" href="a_nil.htm#nil"><b>nil</b></a>. An initialization
argument can be used in two ways: to fill a <a rel="DEFINITION"
href="26_glo_s.htm#slot"><i>slot</i></a> with a value or to provide
an argument for an initialization <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>method</i></a>. A single initialization
argument can be used for both purposes.</p>
<p>An <a rel="DEFINITION" href=
"26_glo_i.htm#initialization_argument_list"><i>initialization
argument list</i></a> is a <a rel="DEFINITION" href=
"26_glo_p.htm#property_list"><i>property list</i></a> of
initialization argument names and values. Its structure is
identical to a <a rel="DEFINITION" href=
"26_glo_p.htm#property_list"><i>property list</i></a> and also to
the portion of an argument list processed for <tt>&amp;key</tt>
parameters. As in those lists, if an initialization argument name
appears more than once in an initialization argument list, the
leftmost occurrence supplies the value and the remaining
occurrences are ignored. The arguments to <a rel="DEFINITION" href=
"f_mk_ins.htm#make-instance"><b>make-instance</b></a> (after the
first argument) form an <a rel="DEFINITION" href=
"26_glo_i.htm#initialization_argument_list"><i>initialization
argument list</i></a>.</p>
<p>An initialization argument can be associated with a <a rel=
"DEFINITION" href="26_glo_s.htm#slot"><i>slot</i></a>. If the
initialization argument has a value in the <a rel="DEFINITION"
href="26_glo_i.htm#initialization_argument_list"><i>initialization
argument list</i></a>, the value is stored into the <a rel=
"DEFINITION" href="26_glo_s.htm#slot"><i>slot</i></a> of the newly
created <a rel="DEFINITION" href=
"26_glo_o.htm#object"><i>object</i></a>, overriding any
<tt>:initform</tt> form associated with the <a rel="DEFINITION"
href="26_glo_s.htm#slot"><i>slot</i></a>. A single initialization
argument can initialize more than one <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a>. An initialization argument
that initializes a <a rel="DEFINITION" href=
"26_glo_s.htm#shared_slot"><i>shared slot</i></a> stores its value
into the <a rel="DEFINITION" href=
"26_glo_s.htm#shared_slot"><i>shared slot</i></a>, replacing any
previous value.</p>
<p>An initialization argument can be associated with a <a rel=
"DEFINITION" href="26_glo_m.htm#method"><i>method</i></a>. When an
<a rel="DEFINITION" href="26_glo_o.htm#object"><i>object</i></a> is
created and a particular initialization argument is supplied, the
<a rel="DEFINITION" href="26_glo_g.htm#generic_function"><i>generic
functions</i></a> <a rel="DEFINITION" href=
"f_init_i.htm#initialize-instance"><b>initialize-instance</b></a>,
<a rel="DEFINITION" href=
"f_shared.htm#shared-initialize"><b>shared-initialize</b></a>, and
<a rel="DEFINITION" href=
"f_alloca.htm#allocate-instance"><b>allocate-instance</b></a> are
called with that initialization argument's name and value as a
keyword argument pair. If a value for the initialization argument
is not supplied in the <a rel="DEFINITION" href=
"26_glo_i.htm#initialization_argument_list"><i>initialization
argument list</i></a>, the <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>method</i></a>'s <a rel="DEFINITION" href=
"26_glo_l.htm#lambda_list"><i>lambda list</i></a> supplies a
default value.</p>
<p>Initialization arguments are used in four situations: when
making an <a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a>, when re-initializing
an <a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a>, when updating an
<a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a> to conform to a
redefined <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a>, and when updating an <a rel=
"DEFINITION" href="26_glo_i.htm#instance"><i>instance</i></a> to
conform to the definition of a different <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a>.</p>
<p>Because initialization arguments are used to control the
creation and initialization of an <a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a> of some particular
<a rel="DEFINITION" href="26_glo_c.htm#class"><i>class</i></a>, we
say that an initialization argument is "an initialization argument
for" that <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a>.</p>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>7.1.2 Declaring the Validity of Initialization Arguments</h2>
<p>Initialization arguments are checked for validity in each of the
four situations that use them. An initialization argument may be
valid in one situation and not another. For example, the
system-supplied primary <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>method</i></a> for <a rel="DEFINITION"
href="f_mk_ins.htm#make-instance"><b>make-instance</b></a> defined
for the <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a> <a rel="DEFINITION" href=
"t_std_cl.htm#standard-class"><b>standard-class</b></a> checks the
validity of its initialization arguments and signals an error if an
initialization argument is supplied that is not declared as valid
in that situation.</p>
<p>There are two means for declaring initialization arguments
valid.</p>
<dl>
<dt>* Initialization arguments that fill <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slots</i></a> are declared as valid by the
<tt>:initarg</tt> slot option to <a rel="DEFINITION" href=
"m_defcla.htm#defclass"><b>defclass</b></a>. The <tt>:initarg</tt>
slot option is inherited from <a rel="DEFINITION" href=
"26_glo_s.htm#superclass"><i>superclasses</i></a>. Thus the set of
valid initialization arguments that fill <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slots</i></a> for a <a rel="DEFINITION"
href="26_glo_c.htm#class"><i>class</i></a> is the union of the
initialization arguments that fill <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slots</i></a> declared as valid by that
<a rel="DEFINITION" href="26_glo_c.htm#class"><i>class</i></a> and
its <a rel="DEFINITION" href=
"26_glo_s.htm#superclass"><i>superclasses</i></a>. Initialization
arguments that fill <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slots</i></a> are valid in all four
contexts.<br></dt>
<dt>* Initialization arguments that supply arguments to <a rel=
"DEFINITION" href="26_glo_m.htm#method"><i>methods</i></a> are
declared as valid by defining those <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>methods</i></a>. The keyword name of each
keyword parameter specified in the <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>method</i></a>'s <a rel="DEFINITION" href=
"26_glo_l.htm#lambda_list"><i>lambda list</i></a> becomes an
initialization argument for all <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>classes</i></a> for which the <a rel=
"DEFINITION" href="26_glo_m.htm#method"><i>method</i></a> is
applicable. The presence of <tt>&amp;allow-other-keys</tt> in the
<a rel="DEFINITION" href="26_glo_l.htm#lambda_list"><i>lambda
list</i></a> of an applicable method disables validity checking of
initialization arguments. Thus <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>method</i></a> inheritance controls the
set of valid initialization arguments that supply arguments to
<a rel="DEFINITION" href="26_glo_m.htm#method"><i>methods</i></a>.
The <a rel="DEFINITION" href=
"26_glo_g.htm#generic_function"><i>generic functions</i></a> for
which <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>method</i></a> definitions serve to
declare initialization arguments valid are as follows:<br></dt>
<dd>
<dl>
<dt>-- Making an <a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a> of a <a rel=
"DEFINITION" href="26_glo_c.htm#class"><i>class</i></a>: <a rel=
"DEFINITION" href=
"f_alloca.htm#allocate-instance"><b>allocate-instance</b></a>,
<a rel="DEFINITION" href=
"f_init_i.htm#initialize-instance"><b>initialize-instance</b></a>,
and <a rel="DEFINITION" href=
"f_shared.htm#shared-initialize"><b>shared-initialize</b></a>.
Initialization arguments declared as valid by these <a rel=
"DEFINITION" href="26_glo_m.htm#method"><i>methods</i></a> are
valid when making an <a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a> of a <a rel=
"DEFINITION" href="26_glo_c.htm#class"><i>class</i></a>.<br></dt>
<dt>-- Re-initializing an <a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a>: <a rel="DEFINITION"
href=
"f_reinit.htm#reinitialize-instance"><b>reinitialize-instance</b></a>
and <a rel="DEFINITION" href=
"f_shared.htm#shared-initialize"><b>shared-initialize</b></a>.
Initialization arguments declared as valid by these <a rel=
"DEFINITION" href="26_glo_m.htm#method"><i>methods</i></a> are
valid when re-initializing an <a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a>.<br></dt>
<dt>-- Updating an <a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a> to conform to a
redefined <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a>: <a rel="DEFINITION" href=
"f_upda_1.htm#update-instance-for-redefined-class"><b>update-instance-for-redefined-class</b></a>
and <a rel="DEFINITION" href=
"f_shared.htm#shared-initialize"><b>shared-initialize</b></a>.
Initialization arguments declared as valid by these <a rel=
"DEFINITION" href="26_glo_m.htm#method"><i>methods</i></a> are
valid when updating an <a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a> to conform to a
redefined <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a>.<br></dt>
<dt>-- Updating an <a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a> to conform to the
definition of a different <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a>: <a rel="DEFINITION" href=
"f_update.htm#update-instance-for-different-class"><b>update-instance-for-different-class</b></a>
and <a rel="DEFINITION" href=
"f_shared.htm#shared-initialize"><b>shared-initialize</b></a>.
Initialization arguments declared as valid by these <a rel=
"DEFINITION" href="26_glo_m.htm#method"><i>methods</i></a> are
valid when updating an <a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a> to conform to the
definition of a different <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a>.<br></dt>
</dl>
</dd>
</dl>
<p>The set of valid initialization arguments for a <a rel=
"DEFINITION" href="26_glo_c.htm#class"><i>class</i></a> is the set
of valid initialization arguments that either fill <a rel=
"DEFINITION" href="26_glo_s.htm#slot"><i>slots</i></a> or supply
arguments to <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>methods</i></a>, along with the predefined
initialization argument <tt>:allow-other-keys</tt>. The default
value for <tt>:allow-other-keys</tt> is <a rel="DEFINITION" href=
"a_nil.htm#nil"><b>nil</b></a>. Validity checking of initialization
arguments is disabled if the value of the initialization argument
<tt>:allow-other-keys</tt> is <a rel="DEFINITION" href=
"26_glo_t.htm#true"><i>true</i></a>.</p>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>7.1.3 Defaulting of Initialization Arguments</h2>
<p>A default value <a rel="DEFINITION" href=
"26_glo_f.htm#form"><i>form</i></a> can be supplied for an
initialization argument by using the <tt>:default-initargs</tt>
<a rel="DEFINITION" href="26_glo_c.htm#class"><i>class</i></a>
option. If an initialization argument is declared valid by some
particular <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a>, its default value form might
be specified by a different <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a>. In this case
<tt>:default-initargs</tt> is used to supply a default value for an
inherited initialization argument.</p>
<p>The <tt>:default-initargs</tt> option is used only to provide
default values for initialization arguments; it does not declare a
<a rel="DEFINITION" href="26_glo_s.htm#symbol"><i>symbol</i></a> as
a valid initialization argument name. Furthermore, the
<tt>:default-initargs</tt> option is used only to provide default
values for initialization arguments when making an <a rel=
"DEFINITION" href="26_glo_i.htm#instance"><i>instance</i></a>.</p>
<p>The argument to the <tt>:default-initargs</tt> class option is a
list of alternating initialization argument names and <a rel=
"DEFINITION" href="26_glo_f.htm#form"><i>forms</i></a>. Each
<a rel="DEFINITION" href="26_glo_f.htm#form"><i>form</i></a> is the
default value form for the corresponding initialization argument.
The default value <a rel="DEFINITION" href=
"26_glo_f.htm#form"><i>form</i></a> of an initialization argument
is used and evaluated only if that initialization argument does not
appear in the arguments to <a rel="DEFINITION" href=
"f_mk_ins.htm#make-instance"><b>make-instance</b></a> and is not
defaulted by a more specific <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a>. The default value <a rel=
"DEFINITION" href="26_glo_f.htm#form"><i>form</i></a> is evaluated
in the lexical environment of the <a rel="DEFINITION" href=
"m_defcla.htm#defclass"><b>defclass</b></a> form that supplied it;
the resulting value is used as the initialization argument's
value.</p>
<p>The initialization arguments supplied to <a rel="DEFINITION"
href="f_mk_ins.htm#make-instance"><b>make-instance</b></a> are
combined with defaulted initialization arguments to produce a
<a rel="DEFINITION" href=
"26_glo_d.htm#defaulted_initialization_argument_list"><i>defaulted
initialization argument list</i></a>. A <a rel="DEFINITION" href=
"26_glo_d.htm#defaulted_initialization_argument_list"><i>defaulted
initialization argument list</i></a> is a list of alternating
initialization argument names and values in which unsupplied
initialization arguments are defaulted and in which the explicitly
supplied initialization arguments appear earlier in the list than
the defaulted initialization arguments. Defaulted initialization
arguments are ordered according to the order in the <a rel=
"DEFINITION" href="26_glo_c.htm#class_precedence_list"><i>class
precedence list</i></a> of the <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>classes</i></a> that supplied the default
values.</p>
<p>There is a distinction between the purposes of the
<tt>:default-initargs</tt> and the <tt>:initform</tt> options with
respect to the initialization of <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slots</i></a>. The
<tt>:default-initargs</tt> class option provides a mechanism for
the user to give a default value <a rel="DEFINITION" href=
"26_glo_f.htm#form"><i>form</i></a> for an initialization argument
without knowing whether the initialization argument initializes a
<a rel="DEFINITION" href="26_glo_s.htm#slot"><i>slot</i></a> or is
passed to a <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>method</i></a>. If that initialization
argument is not explicitly supplied in a call to <a rel=
"DEFINITION" href=
"f_mk_ins.htm#make-instance"><b>make-instance</b></a>, the default
value <a rel="DEFINITION" href="26_glo_f.htm#form"><i>form</i></a>
is used, just as if it had been supplied in the call. In contrast,
the <tt>:initform</tt> slot option provides a mechanism for the
user to give a default initial value form for a <a rel="DEFINITION"
href="26_glo_s.htm#slot"><i>slot</i></a>. An <tt>:initform</tt>
form is used to initialize a <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> only if no initialization
argument associated with that <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> is given as an argument to
<a rel="DEFINITION" href=
"f_mk_ins.htm#make-instance"><b>make-instance</b></a> or is
defaulted by <tt>:default-initargs</tt>.</p>
<p>The order of evaluation of default value <a rel="DEFINITION"
href="26_glo_f.htm#form"><i>forms</i></a> for initialization
arguments and the order of evaluation of <tt>:initform</tt> forms
are undefined. If the order of evaluation is important, <a rel=
"DEFINITION" href=
"f_init_i.htm#initialize-instance"><b>initialize-instance</b></a>
or <a rel="DEFINITION" href=
"f_shared.htm#shared-initialize"><b>shared-initialize</b></a>
<a rel="DEFINITION" href="26_glo_m.htm#method"><i>methods</i></a>
should be used instead.</p>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>7.1.4 Rules for Initialization Arguments</h2>
<p>The <tt>:initarg</tt> slot option may be specified more than
once for a given <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a>.</p>
<p>The following rules specify when initialization arguments may be
multiply defined:</p>
<dl>
<dt>* A given initialization argument can be used to initialize
more than one <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> if the same initialization
argument name appears in more than one <tt>:initarg</tt> slot
option.<br></dt>
<dt>* A given initialization argument name can appear in the
<a rel="DEFINITION" href="26_glo_l.htm#lambda_list"><i>lambda
list</i></a> of more than one initialization <a rel="DEFINITION"
href="26_glo_m.htm#method"><i>method</i></a>.<br></dt>
<dt>* A given initialization argument name can appear both in an
<tt>:initarg</tt> slot option and in the <a rel="DEFINITION" href=
"26_glo_l.htm#lambda_list"><i>lambda list</i></a> of an
initialization <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>method</i></a>.<br></dt>
</dl>
<p>If two or more initialization arguments that initialize the same
<a rel="DEFINITION" href="26_glo_s.htm#slot"><i>slot</i></a> are
given in the arguments to <a rel="DEFINITION" href=
"f_mk_ins.htm#make-instance"><b>make-instance</b></a>, the leftmost
of these initialization arguments in the <a rel="DEFINITION" href=
"26_glo_i.htm#initialization_argument_list"><i>initialization
argument list</i></a> supplies the value, even if the
initialization arguments have different names.</p>
<p>If two or more different initialization arguments that
initialize the same <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> have default values and none is
given explicitly in the arguments to <a rel="DEFINITION" href=
"f_mk_ins.htm#make-instance"><b>make-instance</b></a>, the
initialization argument that appears in a
<tt>:default-initargs</tt> class option in the most specific of the
<a rel="DEFINITION" href="26_glo_c.htm#class"><i>classes</i></a>
supplies the value. If a single <tt>:default-initargs</tt> class
option specifies two or more initialization arguments that
initialize the same <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> and none is given explicitly in
the arguments to <a rel="DEFINITION" href=
"f_mk_ins.htm#make-instance"><b>make-instance</b></a>, the leftmost
in the <tt>:default-initargs</tt> class option supplies the value,
and the values of the remaining default value <a rel="DEFINITION"
href="26_glo_f.htm#form"><i>forms</i></a> are ignored.</p>
<p>Initialization arguments given explicitly in the arguments to
<a rel="DEFINITION" href=
"f_mk_ins.htm#make-instance"><b>make-instance</b></a> appear to the
left of defaulted initialization arguments. Suppose that the
classes C1 and C2 supply the values of defaulted initialization
arguments for different <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slots</i></a>, and suppose that C1 is more
specific than C2; then the defaulted initialization argument whose
value is supplied by C1 is to the left of the defaulted
initialization argument whose value is supplied by C2 in the
<a rel="DEFINITION" href=
"26_glo_d.htm#defaulted_initialization_argument_list"><i>defaulted
initialization argument list</i></a>. If a single
<tt>:default-initargs</tt> class option supplies the values of
initialization arguments for two different <a rel="DEFINITION"
href="26_glo_s.htm#slot"><i>slots</i></a>, the initialization
argument whose value is specified farther to the left in the
<tt>:default-initargs</tt> class option appears farther to the left
in the <a rel="DEFINITION" href=
"26_glo_d.htm#defaulted_initialization_argument_list"><i>defaulted
initialization argument list</i></a>.</p>
<p>If a <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> has both an <tt>:initform</tt>
form and an <tt>:initarg</tt> slot option, and the initialization
argument is defaulted using <tt>:default-initargs</tt> or is
supplied to <a rel="DEFINITION" href=
"f_mk_ins.htm#make-instance"><b>make-instance</b></a>, the captured
<tt>:initform</tt> form is neither used nor evaluated.</p>
<p>The following is an example of the above rules:</p>
<pre>
 (defclass q () ((x :initarg a)))
 (defclass r (q) ((x :initarg b))
   (:default-initargs a 1 b 2))
</pre>
<pre>
                              Defaulted                                         
Form                          Initialization Argument List  Contents of Slot X  
----------
                                                                                
(make-instance 'r)            (a 1 b 2)                     1                   
(make-instance 'r 'a 3)       (a 3 b 2)                     3                   
(make-instance 'r 'b 4)       (b 4 a 1)                     4                   
(make-instance 'r 'a 1 'a 2)  (a 1 a 2 b 2)                 1                   
</pre>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>7.1.5 Shared-Initialize</h2>
<p>The <a rel="DEFINITION" href=
"26_glo_g.htm#generic_function"><i>generic function</i></a> <a rel=
"DEFINITION" href=
"f_shared.htm#shared-initialize"><b>shared-initialize</b></a> is
used to fill the <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slots</i></a> of an <a rel="DEFINITION"
href="26_glo_i.htm#instance"><i>instance</i></a> using
initialization arguments and <tt>:initform</tt> forms when an
<a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a> is created, when an
<a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a> is re-initialized, when
an <a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a> is updated to conform
to a redefined <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a>, and when an <a rel=
"DEFINITION" href="26_glo_i.htm#instance"><i>instance</i></a> is
updated to conform to a different <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a>. It uses standard <a rel=
"DEFINITION" href="26_glo_m.htm#method"><i>method</i></a>
combination. It takes the following arguments: the <a rel=
"DEFINITION" href="26_glo_i.htm#instance"><i>instance</i></a> to be
initialized, a specification of a set of <a rel="DEFINITION" href=
"26_glo_n.htm#name"><i>names</i></a> of <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slots</i></a> <a rel="DEFINITION" href=
"26_glo_a.htm#accessible"><i>accessible</i></a> in that <a rel=
"DEFINITION" href="26_glo_i.htm#instance"><i>instance</i></a>, and
any number of initialization arguments. The arguments after the
first two must form an <a rel="DEFINITION" href=
"26_glo_i.htm#initialization_argument_list"><i>initialization
argument list</i></a>.</p>
<p>The second argument to <a rel="DEFINITION" href=
"f_shared.htm#shared-initialize"><b>shared-initialize</b></a> may
be one of the following:</p>
<dl>
<dt>* It can be a (possibly empty) <a rel="DEFINITION" href=
"26_glo_l.htm#list"><i>list</i></a> of <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> names, which specifies the set
of those <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> names.<br></dt>
<dt>* It can be the symbol <a rel="DEFINITION" href=
"a_t.htm#t"><b>t</b></a>, which specifies the set of all of the
<a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slots</i></a>.<br></dt>
</dl>
<p>There is a system-supplied primary <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>method</i></a> for <a rel="DEFINITION"
href="f_shared.htm#shared-initialize"><b>shared-initialize</b></a>
whose first <a rel="DEFINITION" href=
"26_glo_p.htm#parameter_specializer"><i>parameter
specializer</i></a> is the <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a> <a rel="DEFINITION" href=
"t_std_ob.htm#standard-object"><b>standard-object</b></a>. This
<a rel="DEFINITION" href="26_glo_m.htm#method"><i>method</i></a>
behaves as follows on each <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a>, whether shared or local:</p>
<dl>
<dt>* If an initialization argument in the <a rel="DEFINITION"
href="26_glo_i.htm#initialization_argument_list"><i>initialization
argument list</i></a> specifies a value for that <a rel=
"DEFINITION" href="26_glo_s.htm#slot"><i>slot</i></a>, that value
is stored into the <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a>, even if a value has already
been stored in the <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> before the <a rel="DEFINITION"
href="26_glo_m.htm#method"><i>method</i></a> is run. The affected
<a rel="DEFINITION" href="26_glo_s.htm#slot"><i>slots</i></a> are
independent of which <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slots</i></a> are indicated by the second
argument to <a rel="DEFINITION" href=
"f_shared.htm#shared-initialize"><b>shared-initialize</b></a>.<br></dt>
<dt>* Any <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slots</i></a> indicated by the second
argument that are still unbound at this point are initialized
according to their <tt>:initform</tt> forms. For any such <a rel=
"DEFINITION" href="26_glo_s.htm#slot"><i>slot</i></a> that has an
<tt>:initform</tt> form, that <a rel="DEFINITION" href=
"26_glo_f.htm#form"><i>form</i></a> is evaluated in the lexical
environment of its defining <a rel="DEFINITION" href=
"m_defcla.htm#defclass"><b>defclass</b></a> form and the result is
stored into the <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a>. For example, if a <a rel=
"DEFINITION" href="26_glo_b.htm#before_method"><i>before
method</i></a> stores a value in the <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a>, the <tt>:initform</tt> form
will not be used to supply a value for the <a rel="DEFINITION"
href="26_glo_s.htm#slot"><i>slot</i></a>. If the second argument
specifies a <a rel="DEFINITION" href=
"26_glo_n.htm#name"><i>name</i></a> that does not correspond to any
<a rel="DEFINITION" href="26_glo_s.htm#slot"><i>slots</i></a>
<a rel="DEFINITION" href=
"26_glo_a.htm#accessible"><i>accessible</i></a> in the <a rel=
"DEFINITION" href="26_glo_i.htm#instance"><i>instance</i></a>, the
results are unspecified.<br></dt>
<dt>* The rules mentioned in <a rel="CHILD" href=
"07_ad.htm">Section 7.1.4 (Rules for Initialization Arguments)</a>
are obeyed.<br></dt>
</dl>
<p>The generic function <a rel="DEFINITION" href=
"f_shared.htm#shared-initialize"><b>shared-initialize</b></a> is
called by the system-supplied primary <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>methods</i></a> for <a rel="DEFINITION"
href=
"f_reinit.htm#reinitialize-instance"><b>reinitialize-instance</b></a>,
<a rel="DEFINITION" href=
"f_update.htm#update-instance-for-different-class"><b>update-instance-for-different-class</b></a>,
<a rel="DEFINITION" href=
"f_upda_1.htm#update-instance-for-redefined-class"><b>update-instance-for-redefined-class</b></a>,
and <a rel="DEFINITION" href=
"f_init_i.htm#initialize-instance"><b>initialize-instance</b></a>.
Thus, <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>methods</i></a> can be written for <a rel=
"DEFINITION" href=
"f_shared.htm#shared-initialize"><b>shared-initialize</b></a> to
specify actions that should be taken in all of these contexts.</p>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>7.1.6 Initialize-Instance</h2>
<p>The <a rel="DEFINITION" href=
"26_glo_g.htm#generic_function"><i>generic function</i></a> <a rel=
"DEFINITION" href=
"f_init_i.htm#initialize-instance"><b>initialize-instance</b></a>
is called by <a rel="DEFINITION" href=
"f_mk_ins.htm#make-instance"><b>make-instance</b></a> to initialize
a newly created <a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a>. It uses <a rel=
"DEFINITION" href=
"26_glo_s.htm#standard_method_combination"><i>standard method
combination</i></a>. <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>Methods</i></a> for <a rel="DEFINITION"
href=
"f_init_i.htm#initialize-instance"><b>initialize-instance</b></a>
can be defined in order to perform any initialization that cannot
be achieved simply by supplying initial values for <a rel=
"DEFINITION" href="26_glo_s.htm#slot"><i>slots</i></a>.</p>
<p>During initialization, <a rel="DEFINITION" href=
"f_init_i.htm#initialize-instance"><b>initialize-instance</b></a>
is invoked after the following actions have been taken:</p>
<dl>
<dt>* The <a rel="DEFINITION" href=
"26_glo_d.htm#defaulted_initialization_argument_list"><i>defaulted
initialization argument list</i></a> has been computed by combining
the supplied <a rel="DEFINITION" href=
"26_glo_i.htm#initialization_argument_list"><i>initialization
argument list</i></a> with any default initialization arguments for
the <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a>.<br></dt>
<dt>* The validity of the <a rel="DEFINITION" href=
"26_glo_d.htm#defaulted_initialization_argument_list"><i>defaulted
initialization argument list</i></a> has been checked. If any of
the initialization arguments has not been declared as valid, an
error is signaled.<br></dt>
<dt>* A new <a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a> whose <a rel=
"DEFINITION" href="26_glo_s.htm#slot"><i>slots</i></a> are unbound
has been created.<br></dt>
</dl>
<p>The generic function <a rel="DEFINITION" href=
"f_init_i.htm#initialize-instance"><b>initialize-instance</b></a>
is called with the new <a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a> and the defaulted
initialization arguments. There is a system-supplied primary
<a rel="DEFINITION" href="26_glo_m.htm#method"><i>method</i></a>
for <a rel="DEFINITION" href=
"f_init_i.htm#initialize-instance"><b>initialize-instance</b></a>
whose <a rel="DEFINITION" href=
"26_glo_p.htm#parameter_specializer"><i>parameter
specializer</i></a> is the <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a> <a rel="DEFINITION" href=
"t_std_ob.htm#standard-object"><b>standard-object</b></a>. This
<a rel="DEFINITION" href="26_glo_m.htm#method"><i>method</i></a>
calls the generic function <a rel="DEFINITION" href=
"f_shared.htm#shared-initialize"><b>shared-initialize</b></a> to
fill in the <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slots</i></a> according to the
initialization arguments and the <tt>:initform</tt> forms for the
<a rel="DEFINITION" href="26_glo_s.htm#slot"><i>slots</i></a>; the
generic function <a rel="DEFINITION" href=
"f_shared.htm#shared-initialize"><b>shared-initialize</b></a> is
called with the following arguments: the <a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a>, <a rel="DEFINITION"
href="a_t.htm#t"><b>t</b></a>, and the defaulted initialization
arguments.</p>
<p>Note that <a rel="DEFINITION" href=
"f_init_i.htm#initialize-instance"><b>initialize-instance</b></a>
provides the <a rel="DEFINITION" href=
"26_glo_d.htm#defaulted_initialization_argument_list"><i>defaulted
initialization argument list</i></a> in its call to <a rel=
"DEFINITION" href=
"f_shared.htm#shared-initialize"><b>shared-initialize</b></a>, so
the first step performed by the system-supplied primary <a rel=
"DEFINITION" href="26_glo_m.htm#method"><i>method</i></a> for
<a rel="DEFINITION" href=
"f_shared.htm#shared-initialize"><b>shared-initialize</b></a> takes
into account both the initialization arguments provided in the call
to <a rel="DEFINITION" href=
"f_mk_ins.htm#make-instance"><b>make-instance</b></a> and the
<a rel="DEFINITION" href=
"26_glo_d.htm#defaulted_initialization_argument_list"><i>defaulted
initialization argument list</i></a>.</p>
<p><a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>Methods</i></a> for <a rel="DEFINITION"
href=
"f_init_i.htm#initialize-instance"><b>initialize-instance</b></a>
can be defined to specify actions to be taken when an <a rel=
"DEFINITION" href="26_glo_i.htm#instance"><i>instance</i></a> is
initialized. If only <a rel="DEFINITION" href=
"26_glo_a.htm#after_method"><i>after methods</i></a> for <a rel=
"DEFINITION" href=
"f_init_i.htm#initialize-instance"><b>initialize-instance</b></a>
are defined, they will be run after the system-supplied primary
<a rel="DEFINITION" href="26_glo_m.htm#method"><i>method</i></a>
for initialization and therefore will not interfere with the
default behavior of <a rel="DEFINITION" href=
"f_init_i.htm#initialize-instance"><b>initialize-instance</b></a>.</p>
<p>The object system provides two <a rel="DEFINITION" href=
"26_glo_f.htm#function"><i>functions</i></a> that are useful in the
bodies of <a rel="DEFINITION" href=
"f_init_i.htm#initialize-instance"><b>initialize-instance</b></a>
methods. The <a rel="DEFINITION" href=
"26_glo_f.htm#function"><i>function</i></a> <a rel="DEFINITION"
href="f_slt_bo.htm#slot-boundp"><b>slot-boundp</b></a> returns a
<i>generic boolean</i> value that indicates whether a specified
<a rel="DEFINITION" href="26_glo_s.htm#slot"><i>slot</i></a> has a
value; this provides a mechanism for writing <a rel="DEFINITION"
href="26_glo_a.htm#after_method"><i>after methods</i></a> for
<a rel="DEFINITION" href=
"f_init_i.htm#initialize-instance"><b>initialize-instance</b></a>
that initialize <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slots</i></a> only if they have not already
been initialized. The <a rel="DEFINITION" href=
"26_glo_f.htm#function"><i>function</i></a> <a rel="DEFINITION"
href="f_slt_ma.htm#slot-makunbound"><b>slot-makunbound</b></a>
causes the <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> to have no value.</p>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>7.1.7 Definitions of Make-Instance and Initialize-Instance</h2>
<p>The generic function <a rel="DEFINITION" href=
"f_mk_ins.htm#make-instance"><b>make-instance</b></a> behaves as if
it were defined as follows, except that certain optimizations are
permitted:</p>
<pre>
 (defmethod make-instance ((class standard-class) &amp;rest initargs)
   ...
   (let ((instance (apply #'allocate-instance class initargs)))
     (apply #'initialize-instance instance initargs)
     instance))

 (defmethod make-instance ((class-name symbol) &amp;rest initargs)
   (apply #'make-instance (find-class class-name) initargs))
</pre>
<p>The elided code in the definition of <a rel="DEFINITION" href=
"f_mk_ins.htm#make-instance"><b>make-instance</b></a> augments the
<tt>initargs</tt> with any <i>defaulted initialization
arguments</i> and checks the resulting initialization arguments to
determine whether an initialization argument was supplied that
neither filled a <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> nor supplied an argument to an
applicable <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>method</i></a>.</p>
<p>The generic function <a rel="DEFINITION" href=
"f_init_i.htm#initialize-instance"><b>initialize-instance</b></a>
behaves as if it were defined as follows, except that certain
optimizations are permitted:</p>
<pre>
 (defmethod initialize-instance ((instance standard-object) &amp;rest initargs)
   (apply #'shared-initialize instance t initargs)))
</pre>
<p>These procedures can be customized.</p>
<p>Customizing at the Programmer Interface level includes using the
<tt>:initform</tt>, <tt>:initarg</tt>, and
<tt>:default-initargs</tt> options to <a rel="DEFINITION" href=
"m_defcla.htm#defclass"><b>defclass</b></a>, as well as defining
<a rel="DEFINITION" href="26_glo_m.htm#method"><i>methods</i></a>
for <a rel="DEFINITION" href=
"f_mk_ins.htm#make-instance"><b>make-instance</b></a>, <a rel=
"DEFINITION" href=
"f_alloca.htm#allocate-instance"><b>allocate-instance</b></a>, and
<a rel="DEFINITION" href=
"f_init_i.htm#initialize-instance"><b>initialize-instance</b></a>.
It is also possible to define <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>methods</i></a> for <a rel="DEFINITION"
href="f_shared.htm#shared-initialize"><b>shared-initialize</b></a>,
which would be invoked by the generic functions <a rel="DEFINITION"
href=
"f_reinit.htm#reinitialize-instance"><b>reinitialize-instance</b></a>,
<a rel="DEFINITION" href=
"f_upda_1.htm#update-instance-for-redefined-class"><b>update-instance-for-redefined-class</b></a>,
<a rel="DEFINITION" href=
"f_update.htm#update-instance-for-different-class"><b>update-instance-for-different-class</b></a>,
and <a rel="DEFINITION" href=
"f_init_i.htm#initialize-instance"><b>initialize-instance</b></a>.
The meta-object level supports additional customization.</p>
<p>Implementations are permitted to make certain optimizations to
<a rel="DEFINITION" href=
"f_init_i.htm#initialize-instance"><b>initialize-instance</b></a>
and <a rel="DEFINITION" href=
"f_shared.htm#shared-initialize"><b>shared-initialize</b></a>. The
description of <a rel="DEFINITION" href=
"f_shared.htm#shared-initialize"><b>shared-initialize</b></a> in
Chapter 7 mentions the possible optimizations.</p>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>7.2 Changing the Class of an Instance</h2>
<p>The <a rel="DEFINITION" href=
"26_glo_f.htm#function"><i>function</i></a> <a rel="DEFINITION"
href="f_chg_cl.htm#change-class"><b>change-class</b></a> can be
used to change the <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a> of an <a rel="DEFINITION"
href="26_glo_i.htm#instance"><i>instance</i></a> from its current
class, Cfrom, to a different class, Cto; it changes the structure
of the <a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a> to conform to the
definition of the class Cto.</p>
<p>Note that changing the <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a> of an <a rel="DEFINITION"
href="26_glo_i.htm#instance"><i>instance</i></a> may cause <a rel=
"DEFINITION" href="26_glo_s.htm#slot"><i>slots</i></a> to be added
or deleted. Changing the <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a> of an <a rel="DEFINITION"
href="26_glo_i.htm#instance"><i>instance</i></a> does not change
its identity as defined by the <a rel="DEFINITION" href=
"f_eq.htm#eq"><b>eq</b></a> function.</p>
<p>When <a rel="DEFINITION" href=
"f_chg_cl.htm#change-class"><b>change-class</b></a> is invoked on
an <a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a>, a two-step updating
process takes place. The first step modifies the structure of the
<a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a> by adding new <a rel=
"DEFINITION" href="26_glo_l.htm#local_slot"><i>local slots</i></a>
and discarding <a rel="DEFINITION" href=
"26_glo_l.htm#local_slot"><i>local slots</i></a> that are not
specified in the new version of the <a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a>. The second step
initializes the newly added <a rel="DEFINITION" href=
"26_glo_l.htm#local_slot"><i>local slots</i></a> and performs any
other user-defined actions. These two steps are further described
in the two following sections.</p>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>7.2.1 Modifying the Structure of the Instance</h2>
<p>In order to make the <a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a> conform to the class
Cto, <a rel="DEFINITION" href="26_glo_l.htm#local_slot"><i>local
slots</i></a> specified by the class Cto that are not specified by
the class Cfrom are added, and <a rel="DEFINITION" href=
"26_glo_l.htm#local_slot"><i>local slots</i></a> not specified by
the class Cto that are specified by the class Cfrom are
discarded.</p>
<p>The values of <a rel="DEFINITION" href=
"26_glo_l.htm#local_slot"><i>local slots</i></a> specified by both
the class Cto and the class Cfrom are retained. If such a <a rel=
"DEFINITION" href="26_glo_l.htm#local_slot"><i>local slot</i></a>
was unbound, it remains unbound.</p>
<p>The values of <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slots</i></a> specified as shared in the
class Cfrom and as local in the class Cto are retained.</p>
<p>This first step of the update does not affect the values of any
<a rel="DEFINITION" href="26_glo_s.htm#shared_slot"><i>shared
slots</i></a>.</p>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>7.2.2 Initializing Newly Added Local Slots</h2>
<p>The second step of the update initializes the newly added
<a rel="DEFINITION" href="26_glo_s.htm#slot"><i>slots</i></a> and
performs any other user-defined actions. This step is implemented
by the generic function <a rel="DEFINITION" href=
"f_update.htm#update-instance-for-different-class"><b>update-instance-for-different-class</b></a>.
The generic function <a rel="DEFINITION" href=
"f_update.htm#update-instance-for-different-class"><b>update-instance-for-different-class</b></a>
is invoked by <a rel="DEFINITION" href=
"f_chg_cl.htm#change-class"><b>change-class</b></a> after the first
step of the update has been completed.</p>
<p>The generic function <a rel="DEFINITION" href=
"f_update.htm#update-instance-for-different-class"><b>update-instance-for-different-class</b></a>
is invoked on arguments computed by <a rel="DEFINITION" href=
"f_chg_cl.htm#change-class"><b>change-class</b></a>. The first
argument passed is a copy of the <a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a> being updated and is an
<a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a> of the class Cfrom;
this copy has <a rel="DEFINITION" href=
"26_glo_d.htm#dynamic_extent"><i>dynamic extent</i></a> within the
generic function <a rel="DEFINITION" href=
"f_chg_cl.htm#change-class"><b>change-class</b></a>. The second
argument is the <a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a> as updated so far by
<a rel="DEFINITION" href=
"f_chg_cl.htm#change-class"><b>change-class</b></a> and is an
<a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a> of the class Cto. The
remaining arguments are an <a rel="DEFINITION" href=
"26_glo_i.htm#initialization_argument_list"><i>initialization
argument list</i></a>.</p>
<p>There is a system-supplied primary <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>method</i></a> for <a rel="DEFINITION"
href=
"f_update.htm#update-instance-for-different-class"><b>update-instance-for-different-class</b></a>
that has two parameter specializers, each of which is the <a rel=
"DEFINITION" href="26_glo_c.htm#class"><i>class</i></a> <a rel=
"DEFINITION" href=
"t_std_ob.htm#standard-object"><b>standard-object</b></a>. First
this <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>method</i></a> checks the validity of
initialization arguments and signals an error if an initialization
argument is supplied that is not declared as valid. (For more
information, see <a rel="CHILD" href="07_ab.htm">Section 7.1.2
(Declaring the Validity of Initialization Arguments)</a>.) Then it
calls the generic function <a rel="DEFINITION" href=
"f_shared.htm#shared-initialize"><b>shared-initialize</b></a> with
the following arguments: the new <a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a>, a list of <a rel=
"DEFINITION" href="26_glo_n.htm#name"><i>names</i></a> of the newly
added <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slots</i></a>, and the initialization
arguments it received.</p>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>7.2.3 Customizing the Change of Class of an Instance</h2>
<p><a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>Methods</i></a> for <a rel="DEFINITION"
href=
"f_update.htm#update-instance-for-different-class"><b>update-instance-for-different-class</b></a>
may be defined to specify actions to be taken when an <a rel=
"DEFINITION" href="26_glo_i.htm#instance"><i>instance</i></a> is
updated. If only <a rel="DEFINITION" href=
"26_glo_a.htm#after_method"><i>after methods</i></a> for <a rel=
"DEFINITION" href=
"f_update.htm#update-instance-for-different-class"><b>update-instance-for-different-class</b></a>
are defined, they will be run after the system-supplied primary
<a rel="DEFINITION" href="26_glo_m.htm#method"><i>method</i></a>
for initialization and will not interfere with the default behavior
of <a rel="DEFINITION" href=
"f_update.htm#update-instance-for-different-class"><b>update-instance-for-different-class</b></a>.</p>
<p><a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>Methods</i></a> for <a rel="DEFINITION"
href="f_shared.htm#shared-initialize"><b>shared-initialize</b></a>
may be defined to customize <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a> redefinition. For more
information, see <a rel="CHILD" href="07_ae.htm">Section 7.1.5
(Shared-Initialize)</a>.</p>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>7.3 Reinitializing an Instance</h2>
<p>The generic function <a rel="DEFINITION" href=
"f_reinit.htm#reinitialize-instance"><b>reinitialize-instance</b></a>
may be used to change the values of <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slots</i></a> according to initialization
arguments.</p>
<p>The process of reinitialization changes the values of some
<a rel="DEFINITION" href="26_glo_s.htm#slot"><i>slots</i></a> and
performs any user-defined actions. It does not modify the structure
of an <a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a> to add or delete
<a rel="DEFINITION" href="26_glo_s.htm#slot"><i>slots</i></a>, and
it does not use any <tt>:initform</tt> forms to initialize <a rel=
"DEFINITION" href="26_glo_s.htm#slot"><i>slots</i></a>.</p>
<p>The generic function <a rel="DEFINITION" href=
"f_reinit.htm#reinitialize-instance"><b>reinitialize-instance</b></a>
may be called directly. It takes one required argument, the <a rel=
"DEFINITION" href="26_glo_i.htm#instance"><i>instance</i></a>. It
also takes any number of initialization arguments to be used by
<a rel="DEFINITION" href="26_glo_m.htm#method"><i>methods</i></a>
for <a rel="DEFINITION" href=
"f_reinit.htm#reinitialize-instance"><b>reinitialize-instance</b></a>
or for <a rel="DEFINITION" href=
"f_shared.htm#shared-initialize"><b>shared-initialize</b></a>. The
arguments after the required <a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a> must form an <a rel=
"DEFINITION" href=
"26_glo_i.htm#initialization_argument_list"><i>initialization
argument list</i></a>.</p>
<p>There is a system-supplied primary <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>method</i></a> for <a rel="DEFINITION"
href=
"f_reinit.htm#reinitialize-instance"><b>reinitialize-instance</b></a>
whose <a rel="DEFINITION" href=
"26_glo_p.htm#parameter_specializer"><i>parameter
specializer</i></a> is the <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a> <a rel="DEFINITION" href=
"t_std_ob.htm#standard-object"><b>standard-object</b></a>. First
this <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>method</i></a> checks the validity of
initialization arguments and signals an error if an initialization
argument is supplied that is not declared as valid. (For more
information, see <a rel="CHILD" href="07_ab.htm">Section 7.1.2
(Declaring the Validity of Initialization Arguments)</a>.) Then it
calls the generic function <a rel="DEFINITION" href=
"f_shared.htm#shared-initialize"><b>shared-initialize</b></a> with
the following arguments: the <a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a>, <a rel="DEFINITION"
href="a_nil.htm#nil"><b>nil</b></a>, and the initialization
arguments it received.</p>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>7.3.1 Customizing Reinitialization</h2>
<p><a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>Methods</i></a> for <a rel="DEFINITION"
href=
"f_reinit.htm#reinitialize-instance"><b>reinitialize-instance</b></a>
may be defined to specify actions to be taken when an <a rel=
"DEFINITION" href="26_glo_i.htm#instance"><i>instance</i></a> is
updated. If only <a rel="DEFINITION" href=
"26_glo_a.htm#after_method"><i>after methods</i></a> for <a rel=
"DEFINITION" href=
"f_reinit.htm#reinitialize-instance"><b>reinitialize-instance</b></a>
are defined, they will be run after the system-supplied primary
<a rel="DEFINITION" href="26_glo_m.htm#method"><i>method</i></a>
for initialization and therefore will not interfere with the
default behavior of <a rel="DEFINITION" href=
"f_reinit.htm#reinitialize-instance"><b>reinitialize-instance</b></a>.</p>
<p><a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>Methods</i></a> for <a rel="DEFINITION"
href="f_shared.htm#shared-initialize"><b>shared-initialize</b></a>
may be defined to customize <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a> redefinition. For more
information, see <a rel="CHILD" href="07_ae.htm">Section 7.1.5
(Shared-Initialize)</a>.</p>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>7.4 Meta-Objects</h2>
<p>The implementation of the object system manipulates <a rel=
"DEFINITION" href="26_glo_c.htm#class"><i>classes</i></a>, <a rel=
"DEFINITION" href="26_glo_m.htm#method"><i>methods</i></a>, and
<a rel="DEFINITION" href="26_glo_g.htm#generic_function"><i>generic
functions</i></a>. The object system contains a set of <a rel=
"DEFINITION" href="26_glo_g.htm#generic_function"><i>generic
functions</i></a> defined by <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>methods</i></a> on <a rel="DEFINITION"
href="26_glo_c.htm#class"><i>classes</i></a>; the behavior of those
<a rel="DEFINITION" href="26_glo_g.htm#generic_function"><i>generic
functions</i></a> defines the behavior of the object system. The
<a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instances</i></a> of the <a rel=
"DEFINITION" href="26_glo_c.htm#class"><i>classes</i></a> on which
those <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>methods</i></a> are defined are called
meta-objects.</p>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>7.4.1 Standard Meta-objects</h2>
<p>The object system supplies a set of meta-objects, called
standard meta-objects. These include the <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a> <a rel="DEFINITION" href=
"t_std_ob.htm#standard-object"><b>standard-object</b></a> and
<a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instances</i></a> of the classes <a rel=
"DEFINITION" href=
"t_std_me.htm#standard-method"><b>standard-method</b></a>, <a rel=
"DEFINITION" href=
"t_std_ge.htm#standard-generic-function"><b>standard-generic-function</b></a>,
and <a rel="DEFINITION" href=
"t_meth_1.htm#method-combination"><b>method-combination</b></a>.</p>
<dl>
<dt>* The <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a> <a rel="DEFINITION" href=
"t_std_me.htm#standard-method"><b>standard-method</b></a> is the
default <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a> of <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>methods</i></a> defined by the <a rel=
"DEFINITION" href="m_defmet.htm#defmethod"><b>defmethod</b></a> and
<a rel="DEFINITION" href=
"m_defgen.htm#defgeneric"><b>defgeneric</b></a> <a rel="DEFINITION"
href="26_glo_f.htm#form"><i>forms</i></a>.<br></dt>
<dt>* The <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a> <a rel="DEFINITION" href=
"t_std_ge.htm#standard-generic-function"><b>standard-generic-function</b></a>
is the default <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a> of <a rel="DEFINITION" href=
"26_glo_g.htm#generic_function"><i>generic functions</i></a>
defined by the forms <a rel="DEFINITION" href=
"m_defmet.htm#defmethod"><b>defmethod</b></a>, <a rel="DEFINITION"
href="m_defgen.htm#defgeneric"><b>defgeneric</b></a>, and <a rel=
"DEFINITION" href=
"m_defcla.htm#defclass"><b>defclass</b></a>.<br></dt>
<dt>* The <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a> named <a rel="DEFINITION"
href="t_std_ob.htm#standard-object"><b>standard-object</b></a> is
an <a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a> of the <a rel=
"DEFINITION" href="26_glo_c.htm#class"><i>class</i></a> <a rel=
"DEFINITION" href=
"t_std_cl.htm#standard-class"><b>standard-class</b></a> and is a
<a rel="DEFINITION" href=
"26_glo_s.htm#superclass"><i>superclass</i></a> of every <a rel=
"DEFINITION" href="26_glo_c.htm#class"><i>class</i></a> that is an
<a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a> of <a rel="DEFINITION"
href="t_std_cl.htm#standard-class"><b>standard-class</b></a> except
itself and <a rel="DEFINITION" href=
"t_stu_cl.htm#structure-class"><b>structure-class</b></a>.<br></dt>
<dt>* Every <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>method</i></a> combination object is an
<a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a> of a <a rel=
"DEFINITION" href="26_glo_s.htm#subclass"><i>subclass</i></a> of
<a rel="DEFINITION" href="26_glo_c.htm#class"><i>class</i></a>
<a rel="DEFINITION" href=
"t_meth_1.htm#method-combination"><b>method-combination</b></a>.<br>
</dt>
</dl>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>7.5 Slots</h2>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>7.5.1 Introduction to Slots</h2>
<p>An <a rel="DEFINITION" href=
"26_glo_o.htm#object"><i>object</i></a> of <a rel="DEFINITION"
href="26_glo_m.htm#metaclass"><i>metaclass</i></a> <a rel=
"DEFINITION" href=
"t_std_cl.htm#standard-class"><b>standard-class</b></a> has zero or
more named <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slots</i></a>. The <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slots</i></a> of an <a rel="DEFINITION"
href="26_glo_o.htm#object"><i>object</i></a> are determined by the
<a rel="DEFINITION" href="26_glo_c.htm#class"><i>class</i></a> of
the <a rel="DEFINITION" href=
"26_glo_o.htm#object"><i>object</i></a>. Each <a rel="DEFINITION"
href="26_glo_s.htm#slot"><i>slot</i></a> can hold one value. The
<a rel="DEFINITION" href="26_glo_n.htm#name"><i>name</i></a> of a
<a rel="DEFINITION" href="26_glo_s.htm#slot"><i>slot</i></a> is a
<a rel="DEFINITION" href="26_glo_s.htm#symbol"><i>symbol</i></a>
that is syntactically valid for use as a variable name.</p>
<p>When a <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> does not have a value, the
<a rel="DEFINITION" href="26_glo_s.htm#slot"><i>slot</i></a> is
said to be <a rel="DEFINITION" href=
"26_glo_u.htm#unbound"><i>unbound</i></a>. When an unbound <a rel=
"DEFINITION" href="26_glo_s.htm#slot"><i>slot</i></a> is read, the
<a rel="DEFINITION" href="26_glo_g.htm#generic_function"><i>generic
function</i></a> <a rel="DEFINITION" href=
"f_slt_un.htm#slot-unbound"><b>slot-unbound</b></a> is invoked. The
system-supplied primary <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>method</i></a> for <a rel="DEFINITION"
href="f_slt_un.htm#slot-unbound"><b>slot-unbound</b></a> on <a rel=
"DEFINITION" href="26_glo_c.htm#class"><i>class</i></a> <a rel=
"DEFINITION" href="t_t.htm#t"><b>t</b></a> signals an error. If
<a rel="DEFINITION" href=
"f_slt_un.htm#slot-unbound"><b>slot-unbound</b></a> returns, its
<a rel="DEFINITION" href="26_glo_p.htm#primary_value"><i>primary
value</i></a> is used that time as the <a rel="DEFINITION" href=
"26_glo_v.htm#value"><i>value</i></a> of the <a rel="DEFINITION"
href="26_glo_s.htm#slot"><i>slot</i></a>.</p>
<p>The default initial value form for a <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> is defined by the
<tt>:initform</tt> slot option. When the <tt>:initform</tt> form is
used to supply a value, it is evaluated in the lexical environment
in which the <a rel="DEFINITION" href=
"m_defcla.htm#defclass"><b>defclass</b></a> form was evaluated. The
<tt>:initform</tt> along with the lexical environment in which the
<a rel="DEFINITION" href=
"m_defcla.htm#defclass"><b>defclass</b></a> form was evaluated is
called a <a rel="DEFINITION" href=
"26_glo_c.htm#captured_initialization_form"><i>captured
initialization form</i></a>. For more details, see <a rel="CHILD"
href="07_a.htm">Section 7.1 (Object Creation and
Initialization)</a>.</p>
<p>A <a rel="DEFINITION" href="26_glo_l.htm#local_slot"><i>local
slot</i></a> is defined to be a <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> that is <a rel="DEFINITION"
href="26_glo_a.htm#accessible"><i>accessible</i></a> to exactly one
<a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a>, namely the one in
which the <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> is allocated. A <a rel=
"DEFINITION" href="26_glo_s.htm#shared_slot"><i>shared slot</i></a>
is defined to be a <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> that is visible to more than
one <a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a> of a given <a rel=
"DEFINITION" href="26_glo_c.htm#class"><i>class</i></a> and its
<a rel="DEFINITION" href=
"26_glo_s.htm#subclass"><i>subclasses</i></a>.</p>
<p>A <a rel="DEFINITION" href="26_glo_c.htm#class"><i>class</i></a>
is said to define a <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> with a given <a rel=
"DEFINITION" href="26_glo_n.htm#name"><i>name</i></a> when the
<a rel="DEFINITION" href=
"m_defcla.htm#defclass"><b>defclass</b></a> form for that <a rel=
"DEFINITION" href="26_glo_c.htm#class"><i>class</i></a> contains a
<a rel="DEFINITION" href="26_glo_s.htm#slot_specifier"><i>slot
specifier</i></a> with that <a rel="DEFINITION" href=
"26_glo_n.htm#name"><i>name</i></a>. Defining a <a rel="DEFINITION"
href="26_glo_l.htm#local_slot"><i>local slot</i></a> does not
immediately create a <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a>; it causes a <a rel=
"DEFINITION" href="26_glo_s.htm#slot"><i>slot</i></a> to be created
each time an <a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a> of the <a rel=
"DEFINITION" href="26_glo_c.htm#class"><i>class</i></a> is created.
Defining a <a rel="DEFINITION" href=
"26_glo_s.htm#shared_slot"><i>shared slot</i></a> immediately
creates a <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a>.</p>
<p>The <tt>:allocation</tt> slot option to <a rel="DEFINITION"
href="m_defcla.htm#defclass"><b>defclass</b></a> controls the kind
of <a rel="DEFINITION" href="26_glo_s.htm#slot"><i>slot</i></a>
that is defined. If the value of the <tt>:allocation</tt> slot
option is <tt>:instance</tt>, a <a rel="DEFINITION" href=
"26_glo_l.htm#local_slot"><i>local slot</i></a> is created. If the
value of <tt>:allocation</tt> is <tt>:class</tt>, a <a rel=
"DEFINITION" href="26_glo_s.htm#shared_slot"><i>shared slot</i></a>
is created.</p>
<p>A <a rel="DEFINITION" href="26_glo_s.htm#slot"><i>slot</i></a>
is said to be <a rel="DEFINITION" href=
"26_glo_a.htm#accessible"><i>accessible</i></a> in an <a rel=
"DEFINITION" href="26_glo_i.htm#instance"><i>instance</i></a> of a
<a rel="DEFINITION" href="26_glo_c.htm#class"><i>class</i></a> if
the <a rel="DEFINITION" href="26_glo_s.htm#slot"><i>slot</i></a> is
defined by the <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a> of the <a rel="DEFINITION"
href="26_glo_i.htm#instance"><i>instance</i></a> or is inherited
from a <a rel="DEFINITION" href=
"26_glo_s.htm#superclass"><i>superclass</i></a> of that <a rel=
"DEFINITION" href="26_glo_c.htm#class"><i>class</i></a>. At most
one <a rel="DEFINITION" href="26_glo_s.htm#slot"><i>slot</i></a> of
a given <a rel="DEFINITION" href=
"26_glo_n.htm#name"><i>name</i></a> can be <a rel="DEFINITION"
href="26_glo_a.htm#accessible"><i>accessible</i></a> in an <a rel=
"DEFINITION" href="26_glo_i.htm#instance"><i>instance</i></a>. A
<a rel="DEFINITION" href="26_glo_s.htm#shared_slot"><i>shared
slot</i></a> defined by a <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a> is <a rel="DEFINITION" href=
"26_glo_a.htm#accessible"><i>accessible</i></a> in all <a rel=
"DEFINITION" href="26_glo_i.htm#instance"><i>instances</i></a> of
that <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a>. A detailed explanation of
the inheritance of <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slots</i></a> is given in <a rel="CHILD"
href="07_ec.htm">Section 7.5.3 (Inheritance of Slots and Slot
Options)</a>.</p>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>7.5.2 Accessing Slots</h2>
<p><a rel="DEFINITION" href="26_glo_s.htm#slot"><i>Slots</i></a>
can be <i>accessed</i> in two ways: by use of the primitive
function <a rel="DEFINITION" href=
"f_slt_va.htm#slot-value"><b>slot-value</b></a> and by use of
<a rel="DEFINITION" href="26_glo_g.htm#generic_function"><i>generic
functions</i></a> generated by the <a rel="DEFINITION" href=
"m_defcla.htm#defclass"><b>defclass</b></a> form.</p>
<p>The <a rel="DEFINITION" href=
"26_glo_f.htm#function"><i>function</i></a> <a rel="DEFINITION"
href="f_slt_va.htm#slot-value"><b>slot-value</b></a> can be used
with any of the <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> names specified in the <a rel=
"DEFINITION" href="m_defcla.htm#defclass"><b>defclass</b></a> form
to <a rel="DEFINITION" href="26_glo_a.htm#access"><i>access</i></a>
a specific <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> <a rel="DEFINITION" href=
"26_glo_a.htm#accessible"><i>accessible</i></a> in an <a rel=
"DEFINITION" href="26_glo_i.htm#instance"><i>instance</i></a> of
the given <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a>.</p>
<p>The macro <a rel="DEFINITION" href=
"m_defcla.htm#defclass"><b>defclass</b></a> provides syntax for
generating <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>methods</i></a> to read and write <a rel=
"DEFINITION" href="26_glo_s.htm#slot"><i>slots</i></a>. If a reader
<a rel="DEFINITION" href="26_glo_m.htm#method"><i>method</i></a> is
requested, a <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>method</i></a> is automatically generated
for reading the value of the <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a>, but no <a rel="DEFINITION"
href="26_glo_m.htm#method"><i>method</i></a> for storing a value
into it is generated. If a writer <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>method</i></a> is requested, a <a rel=
"DEFINITION" href="26_glo_m.htm#method"><i>method</i></a> is
automatically generated for storing a value into the <a rel=
"DEFINITION" href="26_glo_s.htm#slot"><i>slot</i></a>, but no
<a rel="DEFINITION" href="26_glo_m.htm#method"><i>method</i></a>
for reading its value is generated. If an accessor <a rel=
"DEFINITION" href="26_glo_m.htm#method"><i>method</i></a> is
requested, a <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>method</i></a> for reading the value of
the <a rel="DEFINITION" href="26_glo_s.htm#slot"><i>slot</i></a>
and a <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>method</i></a> for storing a value into
the <a rel="DEFINITION" href="26_glo_s.htm#slot"><i>slot</i></a>
are automatically generated. Reader and writer <a rel="DEFINITION"
href="26_glo_m.htm#method"><i>methods</i></a> are implemented using
<a rel="DEFINITION" href=
"f_slt_va.htm#slot-value"><b>slot-value</b></a>.</p>
<p>When a reader or writer <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>method</i></a> is specified for a <a rel=
"DEFINITION" href="26_glo_s.htm#slot"><i>slot</i></a>, the name of
the <a rel="DEFINITION" href=
"26_glo_g.htm#generic_function"><i>generic function</i></a> to
which the generated <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>method</i></a> belongs is directly
specified. If the <a rel="DEFINITION" href=
"26_glo_n.htm#name"><i>name</i></a> specified for the writer
<a rel="DEFINITION" href="26_glo_m.htm#method"><i>method</i></a> is
the symbol <tt>name</tt>, the <a rel="DEFINITION" href=
"26_glo_n.htm#name"><i>name</i></a> of the <a rel="DEFINITION"
href="26_glo_g.htm#generic_function"><i>generic function</i></a>
for writing the <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> is the symbol <tt>name</tt>,
and the <a rel="DEFINITION" href=
"26_glo_g.htm#generic_function"><i>generic function</i></a> takes
two arguments: the new value and the <a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a>, in that order. If the
<a rel="DEFINITION" href="26_glo_n.htm#name"><i>name</i></a>
specified for the accessor <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>method</i></a> is the symbol
<tt>name</tt>, the <a rel="DEFINITION" href=
"26_glo_n.htm#name"><i>name</i></a> of the <a rel="DEFINITION"
href="26_glo_g.htm#generic_function"><i>generic function</i></a>
for reading the <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> is the symbol <tt>name</tt>,
and the <a rel="DEFINITION" href=
"26_glo_n.htm#name"><i>name</i></a> of the <a rel="DEFINITION"
href="26_glo_g.htm#generic_function"><i>generic function</i></a>
for writing the <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> is the list <tt>(setf
name)</tt>.</p>
<p>A <a rel="DEFINITION" href=
"26_glo_g.htm#generic_function"><i>generic function</i></a> created
or modified by supplying <tt>:reader</tt>, <tt>:writer</tt>, or
<tt>:accessor</tt> <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> options can be treated exactly
as an ordinary <a rel="DEFINITION" href=
"26_glo_g.htm#generic_function"><i>generic function</i></a>.</p>
<p>Note that <a rel="DEFINITION" href=
"f_slt_va.htm#slot-value"><b>slot-value</b></a> can be used to read
or write the value of a <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> whether or not reader or writer
<a rel="DEFINITION" href="26_glo_m.htm#method"><i>methods</i></a>
exist for that <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a>. When <a rel="DEFINITION" href=
"f_slt_va.htm#slot-value"><b>slot-value</b></a> is used, no reader
or writer <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>methods</i></a> are invoked.</p>
<p>The macro <a rel="DEFINITION" href=
"m_w_slts.htm#with-slots"><b>with-slots</b></a> can be used to
establish a <a rel="DEFINITION" href=
"26_glo_l.htm#lexical_environment"><i>lexical environment</i></a>
in which specified <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slots</i></a> are lexically available as if
they were variables. The macro <a rel="DEFINITION" href=
"m_w_slts.htm#with-slots"><b>with-slots</b></a> invokes the <a rel=
"DEFINITION" href="26_glo_f.htm#function"><i>function</i></a>
<a rel="DEFINITION" href=
"f_slt_va.htm#slot-value"><b>slot-value</b></a> to <a rel=
"DEFINITION" href="26_glo_a.htm#access"><i>access</i></a> the
specified <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slots</i></a>.</p>
<p>The macro <a rel="DEFINITION" href=
"m_w_acce.htm#with-accessors"><b>with-accessors</b></a> can be used
to establish a lexical environment in which specified <a rel=
"DEFINITION" href="26_glo_s.htm#slot"><i>slots</i></a> are
lexically available through their accessors as if they were
variables. The macro <a rel="DEFINITION" href=
"m_w_acce.htm#with-accessors"><b>with-accessors</b></a> invokes the
appropriate accessors to <a rel="DEFINITION" href=
"26_glo_a.htm#access"><i>access</i></a> the specified <a rel=
"DEFINITION" href="26_glo_s.htm#slot"><i>slots</i></a>.</p>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>7.5.3 Inheritance of Slots and Slot Options</h2>
<p>The set of the <a rel="DEFINITION" href=
"26_glo_n.htm#name"><i>names</i></a> of all <a rel="DEFINITION"
href="26_glo_s.htm#slot"><i>slots</i></a> <a rel="DEFINITION" href=
"26_glo_a.htm#accessible"><i>accessible</i></a> in an <a rel=
"DEFINITION" href="26_glo_i.htm#instance"><i>instance</i></a> of a
<a rel="DEFINITION" href="26_glo_c.htm#class"><i>class</i></a> C is
the union of the sets of <a rel="DEFINITION" href=
"26_glo_n.htm#name"><i>names</i></a> of <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slots</i></a> defined by C and its <a rel=
"DEFINITION" href=
"26_glo_s.htm#superclass"><i>superclasses</i></a>. The structure of
an <a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a> is the set of <a rel=
"DEFINITION" href="26_glo_n.htm#name"><i>names</i></a> of <a rel=
"DEFINITION" href="26_glo_l.htm#local_slot"><i>local slots</i></a>
in that <a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a>.</p>
<p>In the simplest case, only one <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a> among C and its <a rel=
"DEFINITION" href="26_glo_s.htm#superclass"><i>superclasses</i></a>
defines a <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> with a given <a rel=
"DEFINITION" href="26_glo_s.htm#slot"><i>slot</i></a> name. If a
<a rel="DEFINITION" href="26_glo_s.htm#slot"><i>slot</i></a> is
defined by a <a rel="DEFINITION" href=
"26_glo_s.htm#superclass"><i>superclass</i></a> of C, the <a rel=
"DEFINITION" href="26_glo_s.htm#slot"><i>slot</i></a> is said to be
inherited. The characteristics of the <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> are determined by the <a rel=
"DEFINITION" href="26_glo_s.htm#slot_specifier"><i>slot
specifier</i></a> of the defining <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a>. Consider the defining
<a rel="DEFINITION" href="26_glo_c.htm#class"><i>class</i></a> for
a slot S. If the value of the <tt>:allocation</tt> slot option is
<tt>:instance</tt>, then S is a <a rel="DEFINITION" href=
"26_glo_l.htm#local_slot"><i>local slot</i></a> and each <a rel=
"DEFINITION" href="26_glo_i.htm#instance"><i>instance</i></a> of C
has its own <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> named S that stores its own
value. If the value of the <tt>:allocation</tt> slot option is
<tt>:class</tt>, then S is a <a rel="DEFINITION" href=
"26_glo_s.htm#shared_slot"><i>shared slot</i></a>, the <a rel=
"DEFINITION" href="26_glo_c.htm#class"><i>class</i></a> that
defined S stores the value, and all <a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instances</i></a> of C can <a rel=
"DEFINITION" href="26_glo_a.htm#access"><i>access</i></a> that
single <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a>. If the <tt>:allocation</tt>
slot option is omitted, <tt>:instance</tt> is used.</p>
<p>In general, more than one <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a> among C and its <a rel=
"DEFINITION" href="26_glo_s.htm#superclass"><i>superclasses</i></a>
can define a <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> with a given <a rel=
"DEFINITION" href="26_glo_n.htm#name"><i>name</i></a>. In such
cases, only one <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> with the given name is <a rel=
"DEFINITION" href="26_glo_a.htm#accessible"><i>accessible</i></a>
in an <a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a> of C, and the
characteristics of that <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> are a combination of the
several <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> specifiers, computed as
follows:</p>
<dl>
<dt>* All the <a rel="DEFINITION" href=
"26_glo_s.htm#slot_specifier"><i>slot specifiers</i></a> for a
given <a rel="DEFINITION" href="26_glo_s.htm#slot"><i>slot</i></a>
name are ordered from most specific to least specific, according to
the order in C's <a rel="DEFINITION" href=
"26_glo_c.htm#class_precedence_list"><i>class precedence
list</i></a> of the <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>classes</i></a> that define them. All
references to the specificity of <a rel="DEFINITION" href=
"26_glo_s.htm#slot_specifier"><i>slot specifiers</i></a>
immediately below refers to this ordering.<br></dt>
<dt>* The allocation of a <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> is controlled by the most
specific <a rel="DEFINITION" href=
"26_glo_s.htm#slot_specifier"><i>slot specifier</i></a>. If the
most specific <a rel="DEFINITION" href=
"26_glo_s.htm#slot_specifier"><i>slot specifier</i></a> does not
contain an <tt>:allocation</tt> slot option, <tt>:instance</tt> is
used. Less specific <a rel="DEFINITION" href=
"26_glo_s.htm#slot_specifier"><i>slot specifiers</i></a> do not
affect the allocation.<br></dt>
<dt>* The default initial value form for a <a rel="DEFINITION"
href="26_glo_s.htm#slot"><i>slot</i></a> is the value of the
<tt>:initform</tt> slot option in the most specific <a rel=
"DEFINITION" href="26_glo_s.htm#slot_specifier"><i>slot
specifier</i></a> that contains one. If no <a rel="DEFINITION"
href="26_glo_s.htm#slot_specifier"><i>slot specifier</i></a>
contains an <tt>:initform</tt> slot option, the <a rel="DEFINITION"
href="26_glo_s.htm#slot"><i>slot</i></a> has no default initial
value form.<br></dt>
<dt>* The contents of a <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> will always be of type <tt>(and
T</tt>1 <tt>... T</tt>n<tt>)</tt> where T1 ...Tn are the values of
the <tt>:type</tt> slot options contained in all of the <a rel=
"DEFINITION" href="26_glo_s.htm#slot_specifier"><i>slot
specifiers</i></a>. If no <a rel="DEFINITION" href=
"26_glo_s.htm#slot_specifier"><i>slot specifier</i></a> contains
the <tt>:type</tt> slot option, the contents of the <a rel=
"DEFINITION" href="26_glo_s.htm#slot"><i>slot</i></a> will always
be of <a rel="DEFINITION" href="26_glo_t.htm#type"><i>type</i></a>
<a rel="DEFINITION" href="t_t.htm#t"><b>t</b></a>. The consequences
of attempting to store in a <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> a value that does not satisfy
the <a rel="DEFINITION" href="26_glo_t.htm#type"><i>type</i></a> of
the <a rel="DEFINITION" href="26_glo_s.htm#slot"><i>slot</i></a>
are undefined.<br></dt>
<dt>* The set of initialization arguments that initialize a given
<a rel="DEFINITION" href="26_glo_s.htm#slot"><i>slot</i></a> is the
union of the initialization arguments declared in the
<tt>:initarg</tt> slot options in all the <a rel="DEFINITION" href=
"26_glo_s.htm#slot_specifier"><i>slot specifiers</i></a>.<br></dt>
<dt>* The <a rel="DEFINITION" href=
"26_glo_d.htm#documentation_string"><i>documentation string</i></a>
for a <a rel="DEFINITION" href="26_glo_s.htm#slot"><i>slot</i></a>
is the value of the <tt>:documentation</tt> slot option in the most
specific <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> specifier that contains one. If
no <a rel="DEFINITION" href="26_glo_s.htm#slot_specifier"><i>slot
specifier</i></a> contains a <tt>:documentation</tt> slot option,
the <a rel="DEFINITION" href="26_glo_s.htm#slot"><i>slot</i></a>
has no <a rel="DEFINITION" href=
"26_glo_d.htm#documentation_string"><i>documentation
string</i></a>.<br></dt>
</dl>
<p>A consequence of the allocation rule is that a <a rel=
"DEFINITION" href="26_glo_s.htm#shared_slot"><i>shared slot</i></a>
can be <i>shadowed</i>. For example, if a class C1 defines a
<a rel="DEFINITION" href="26_glo_s.htm#slot"><i>slot</i></a> named
S whose value for the <tt>:allocation</tt> slot option is
<tt>:class</tt>, that <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> is <a rel="DEFINITION" href=
"26_glo_a.htm#accessible"><i>accessible</i></a> in <a rel=
"DEFINITION" href="26_glo_i.htm#instance"><i>instances</i></a> of
C1 and all of its <a rel="DEFINITION" href=
"26_glo_s.htm#subclass"><i>subclasses</i></a>. However, if C2 is a
<a rel="DEFINITION" href=
"26_glo_s.htm#subclass"><i>subclass</i></a> of C1 and also defines
a <a rel="DEFINITION" href="26_glo_s.htm#slot"><i>slot</i></a>
named S, C1's <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> is not shared by <a rel=
"DEFINITION" href="26_glo_i.htm#instance"><i>instances</i></a> of
C2 and its <a rel="DEFINITION" href=
"26_glo_s.htm#subclass"><i>subclasses</i></a>. When a class C1
defines a <a rel="DEFINITION" href=
"26_glo_s.htm#shared_slot"><i>shared slot</i></a>, any subclass C2
of C1 will share this single <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> unless the <a rel="DEFINITION"
href="m_defcla.htm#defclass"><b>defclass</b></a> form for C2
specifies a <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> of the same <a rel="DEFINITION"
href="26_glo_n.htm#name"><i>name</i></a> or there is a <a rel=
"DEFINITION" href="26_glo_s.htm#superclass"><i>superclass</i></a>
of C2 that precedes C1 in the <a rel="DEFINITION" href=
"26_glo_c.htm#class_precedence_list"><i>class precedence
list</i></a> of C2 that defines a <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> of the same name.</p>
<p>A consequence of the type rule is that the value of a <a rel=
"DEFINITION" href="26_glo_s.htm#slot"><i>slot</i></a> satisfies the
type constraint of each <a rel="DEFINITION" href=
"26_glo_s.htm#slot_specifier"><i>slot specifier</i></a> that
contributes to that <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a>. Because the result of
attempting to store in a <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> a value that does not satisfy
the type constraint for the <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a> is undefined, the value in a
<a rel="DEFINITION" href="26_glo_s.htm#slot"><i>slot</i></a> might
fail to satisfy its type constraint.</p>
<p>The <tt>:reader</tt>, <tt>:writer</tt>, and <tt>:accessor</tt>
slot options create <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>methods</i></a> rather than define the
characteristics of a <a rel="DEFINITION" href=
"26_glo_s.htm#slot"><i>slot</i></a>. Reader and writer <a rel=
"DEFINITION" href="26_glo_m.htm#method"><i>methods</i></a> are
inherited in the sense described in <a rel="CHILD" href=
"07_fg.htm">Section 7.6.7 (Inheritance of Methods)</a>.</p>
<p><a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>Methods</i></a> that <a rel="DEFINITION"
href="26_glo_a.htm#access"><i>access</i></a> <a rel="DEFINITION"
href="26_glo_s.htm#slot"><i>slots</i></a> use only the name of the
<a rel="DEFINITION" href="26_glo_s.htm#slot"><i>slot</i></a> and
the <a rel="DEFINITION" href="26_glo_t.htm#type"><i>type</i></a> of
the <a rel="DEFINITION" href="26_glo_s.htm#slot"><i>slot</i></a>'s
value. Suppose a <a rel="DEFINITION" href=
"26_glo_s.htm#superclass"><i>superclass</i></a> provides a <a rel=
"DEFINITION" href="26_glo_m.htm#method"><i>method</i></a> that
expects to <a rel="DEFINITION" href=
"26_glo_a.htm#access"><i>access</i></a> a <a rel="DEFINITION" href=
"26_glo_s.htm#shared_slot"><i>shared slot</i></a> of a given
<a rel="DEFINITION" href="26_glo_n.htm#name"><i>name</i></a>, and a
<a rel="DEFINITION" href=
"26_glo_s.htm#subclass"><i>subclass</i></a> defines a <a rel=
"DEFINITION" href="26_glo_l.htm#local_slot"><i>local slot</i></a>
with the same <a rel="DEFINITION" href=
"26_glo_n.htm#name"><i>name</i></a>. If the <a rel="DEFINITION"
href="26_glo_m.htm#method"><i>method</i></a> provided by the
<a rel="DEFINITION" href=
"26_glo_s.htm#superclass"><i>superclass</i></a> is used on an
<a rel="DEFINITION" href=
"26_glo_i.htm#instance"><i>instance</i></a> of the <a rel=
"DEFINITION" href="26_glo_s.htm#subclass"><i>subclass</i></a>, the
<a rel="DEFINITION" href="26_glo_m.htm#method"><i>method</i></a>
<a rel="DEFINITION" href="26_glo_a.htm#access"><i>accesses</i></a>
the <a rel="DEFINITION" href="26_glo_l.htm#local_slot"><i>local
slot</i></a>.</p>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>7.6 Generic Functions and Methods</h2>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>7.6.1 Introduction to Generic Functions</h2>
<p>A <a rel="DEFINITION" href=
"26_glo_g.htm#generic_function"><i>generic function</i></a> is a
function whose behavior depends on the <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>classes</i></a> or identities of the
<a rel="DEFINITION" href=
"26_glo_a.htm#argument"><i>arguments</i></a> supplied to it. A
<a rel="DEFINITION" href="26_glo_g.htm#generic_function"><i>generic
function</i></a> <a rel="DEFINITION" href=
"26_glo_o.htm#object"><i>object</i></a> is associated with a set of
<a rel="DEFINITION" href="26_glo_m.htm#method"><i>methods</i></a>,
a <a rel="DEFINITION" href="26_glo_l.htm#lambda_list"><i>lambda
list</i></a>, a <a rel="DEFINITION" href=
"26_glo_m.htm#method_combination"><i>method combination</i></a>[2],
and other information.</p>
<p>Like an <a rel="DEFINITION" href=
"26_glo_o.htm#ordinary_function"><i>ordinary function</i></a>, a
<a rel="DEFINITION" href="26_glo_g.htm#generic_function"><i>generic
function</i></a> takes <a rel="DEFINITION" href=
"26_glo_a.htm#argument"><i>arguments</i></a>, performs a series of
operations, and perhaps returns useful <a rel="DEFINITION" href=
"26_glo_v.htm#value"><i>values</i></a>. An <a rel="DEFINITION"
href="26_glo_o.htm#ordinary_function"><i>ordinary function</i></a>
has a single body of <a rel="DEFINITION" href=
"26_glo_c.htm#code"><i>code</i></a> that is always <i>executed</i>
when the <a rel="DEFINITION" href=
"26_glo_f.htm#function"><i>function</i></a> is called. A <a rel=
"DEFINITION" href="26_glo_g.htm#generic_function"><i>generic
function</i></a> has a set of bodies of <a rel="DEFINITION" href=
"26_glo_c.htm#code"><i>code</i></a> of which a subset is selected
for <i>execution</i>. The selected bodies of <a rel="DEFINITION"
href="26_glo_c.htm#code"><i>code</i></a> and the manner of their
combination are determined by the <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>classes</i></a> or identities of one or
more of the <a rel="DEFINITION" href=
"26_glo_a.htm#argument"><i>arguments</i></a> to the <a rel=
"DEFINITION" href="26_glo_g.htm#generic_function"><i>generic
function</i></a> and by its <a rel="DEFINITION" href=
"26_glo_m.htm#method_combination"><i>method
combination</i></a>.</p>
<p><a rel="DEFINITION" href=
"26_glo_o.htm#ordinary_function"><i>Ordinary functions</i></a> and
<a rel="DEFINITION" href="26_glo_g.htm#generic_function"><i>generic
functions</i></a> are called with identical syntax.</p>
<p><a rel="DEFINITION" href=
"26_glo_g.htm#generic_function"><i>Generic functions</i></a> are
true <a rel="DEFINITION" href=
"26_glo_f.htm#function"><i>functions</i></a> that can be passed as
<a rel="DEFINITION" href=
"26_glo_a.htm#argument"><i>arguments</i></a> and used as the first
<a rel="DEFINITION" href=
"26_glo_a.htm#argument"><i>argument</i></a> to <a rel="DEFINITION"
href="f_funcal.htm#funcall"><b>funcall</b></a> and <a rel=
"DEFINITION" href="f_apply.htm#apply"><b>apply</b></a>.</p>
<p>A <a rel="DEFINITION" href=
"26_glo_b.htm#binding"><i>binding</i></a> of a <a rel="DEFINITION"
href="26_glo_f.htm#function_name"><i>function name</i></a> to a
<a rel="DEFINITION" href="26_glo_g.htm#generic_function"><i>generic
function</i></a> can be <i>established</i> in one of several ways.
It can be <i>established</i> in the <a rel="DEFINITION" href=
"26_glo_g.htm#global_environment"><i>global environment</i></a> by
<a rel="DEFINITION" href=
"f_ensure.htm#ensure-generic-function"><b>ensure-generic-function</b></a>,
<a rel="DEFINITION" href=
"m_defmet.htm#defmethod"><b>defmethod</b></a> (implicitly, due to
<a rel="DEFINITION" href=
"f_ensure.htm#ensure-generic-function"><b>ensure-generic-function</b></a>)
or <a rel="DEFINITION" href=
"m_defgen.htm#defgeneric"><b>defgeneric</b></a> (also implicitly,
due to <a rel="DEFINITION" href=
"f_ensure.htm#ensure-generic-function"><b>ensure-generic-function</b></a>).
No <a rel="DEFINITION" href=
"26_glo_s.htm#standardized"><i>standardized</i></a> mechanism is
provided for <i>establishing</i> a <a rel="DEFINITION" href=
"26_glo_b.htm#binding"><i>binding</i></a> of a <a rel="DEFINITION"
href="26_glo_f.htm#function_name"><i>function name</i></a> to a
<a rel="DEFINITION" href="26_glo_g.htm#generic_function"><i>generic
function</i></a> in the <a rel="DEFINITION" href=
"26_glo_l.htm#lexical_environment"><i>lexical
environment</i></a>.</p>
<p>When a <a rel="DEFINITION" href=
"m_defgen.htm#defgeneric"><b>defgeneric</b></a> form is evaluated,
one of three actions is taken (due to <a rel="DEFINITION" href=
"f_ensure.htm#ensure-generic-function"><b>ensure-generic-function</b></a>):</p>
<dl>
<dt>* If a generic function of the given name already exists, the
existing generic function object is modified. Methods specified by
the current <a rel="DEFINITION" href=
"m_defgen.htm#defgeneric"><b>defgeneric</b></a> form are added, and
any methods in the existing generic function that were defined by a
previous <a rel="DEFINITION" href=
"m_defgen.htm#defgeneric"><b>defgeneric</b></a> form are removed.
Methods added by the current <a rel="DEFINITION" href=
"m_defgen.htm#defgeneric"><b>defgeneric</b></a> form might replace
methods defined by <a rel="DEFINITION" href=
"m_defmet.htm#defmethod"><b>defmethod</b></a>, <a rel="DEFINITION"
href="m_defcla.htm#defclass"><b>defclass</b></a>, <a rel=
"DEFINITION" href=
"m_defi_5.htm#define-condition"><b>define-condition</b></a>, or
<a rel="DEFINITION" href=
"m_defstr.htm#defstruct"><b>defstruct</b></a>. No other methods in
the generic function are affected or replaced.<br></dt>
<dt>* If the given name names an <a rel="DEFINITION" href=
"26_glo_o.htm#ordinary_function"><i>ordinary function</i></a>, a
<a rel="DEFINITION" href="26_glo_m.htm#macro"><i>macro</i></a>, or
a <a rel="DEFINITION" href=
"26_glo_s.htm#special_operator"><i>special operator</i></a>, an
error is signaled.<br></dt>
<dt>* Otherwise a generic function is created with the methods
specified by the method definitions in the <a rel="DEFINITION"
href="m_defgen.htm#defgeneric"><b>defgeneric</b></a> form.<br></dt>
</dl>
<p>Some <a rel="DEFINITION" href=
"26_glo_o.htm#operator"><i>operators</i></a> permit specification
of the options of a <a rel="DEFINITION" href=
"26_glo_g.htm#generic_function"><i>generic function</i></a>, such
as the <a rel="DEFINITION" href="26_glo_t.htm#type"><i>type</i></a>
of <a rel="DEFINITION" href=
"26_glo_m.htm#method_combination"><i>method combination</i></a> it
uses or its <a rel="DEFINITION" href=
"26_glo_a.htm#argument_precedence_order"><i>argument precedence
order</i></a>. These <a rel="DEFINITION" href=
"26_glo_o.htm#operator"><i>operators</i></a> will be referred to as
"operators that specify generic function options." The only <a rel=
"DEFINITION" href=
"26_glo_s.htm#standardized"><i>standardized</i></a> <a rel=
"DEFINITION" href="26_glo_o.htm#operator"><i>operator</i></a> in
this category is <a rel="DEFINITION" href=
"m_defgen.htm#defgeneric"><b>defgeneric</b></a>.</p>
<p>Some <a rel="DEFINITION" href=
"26_glo_o.htm#operator"><i>operators</i></a> define <a rel=
"DEFINITION" href="26_glo_m.htm#method"><i>methods</i></a> for a
<a rel="DEFINITION" href="26_glo_g.htm#generic_function"><i>generic
function</i></a>. These <a rel="DEFINITION" href=
"26_glo_o.htm#operator"><i>operators</i></a> will be referred to as
<a rel="DEFINITION" href=
"26_glo_m.htm#method-defining_operator"><i>method-defining
operators</i></a>; their associated <a rel="DEFINITION" href=
"26_glo_f.htm#form"><i>forms</i></a> are called <a rel="DEFINITION"
href="26_glo_m.htm#method-defining_form"><i>method-defining
forms</i></a>. The <a rel="DEFINITION" href=
"26_glo_s.htm#standardized"><i>standardized</i></a> <a rel=
"DEFINITION" href=
"26_glo_m.htm#method-defining_operator"><i>method-defining
operators</i></a> are listed in the next figure. <a name=
"stdmethdefops" id="stdmethdefops"></a></p>
<pre>
<a rel="DEFINITION" href=
"m_defgen.htm#defgeneric">defgeneric</a>        <a rel="DEFINITION"
href="m_defmet.htm#defmethod">defmethod</a>  <a rel="DEFINITION"
href="m_defcla.htm#defclass">defclass</a>  
<a rel="DEFINITION" href=
"m_defi_5.htm#define-condition">define-condition</a>  <a rel=
"DEFINITION" href=
"m_defstr.htm#defstruct">defstruct</a>            
</pre>
<p><b>Figure 7-1. Standardized Method-Defining Operators</b> Note
that of the <a rel="DEFINITION" href=
"26_glo_s.htm#standardized"><i>standardized</i></a> <a rel=
"DEFINITION" href=
"26_glo_m.htm#method-defining_operator"><i>method-defining
operators</i></a> only <a rel="DEFINITION" href=
"m_defgen.htm#defgeneric"><b>defgeneric</b></a> can specify <a rel=
"DEFINITION" href="26_glo_g.htm#generic_function"><i>generic
function</i></a> options. <a rel="DEFINITION" href=
"m_defgen.htm#defgeneric"><b>defgeneric</b></a> and any <a rel=
"DEFINITION" href=
"26_glo_i.htm#implementation-defined"><i>implementation-defined</i></a>
<a rel="DEFINITION" href=
"26_glo_o.htm#operator"><i>operators</i></a> that can specify
<a rel="DEFINITION" href="26_glo_g.htm#generic_function"><i>generic
function</i></a> options are also referred to as "operators that
specify generic function options."</p>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>7.6.2 Introduction to Methods</h2>
<p><a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>Methods</i></a> define the class-specific
or identity-specific behavior and operations of a <a rel=
"DEFINITION" href="26_glo_g.htm#generic_function"><i>generic
function</i></a>.</p>
<p>A <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>method</i></a> <a rel="DEFINITION" href=
"26_glo_o.htm#object"><i>object</i></a> is associated with <a rel=
"DEFINITION" href="26_glo_c.htm#code"><i>code</i></a> that
implements the method's behavior, a sequence of <a rel="DEFINITION"
href="26_glo_p.htm#parameter_specializer"><i>parameter
specializers</i></a> that specify when the given <a rel=
"DEFINITION" href="26_glo_m.htm#method"><i>method</i></a> is
applicable, a <a rel="DEFINITION" href=
"26_glo_l.htm#lambda_list"><i>lambda list</i></a>, and a sequence
of <a rel="DEFINITION" href=
"26_glo_q.htm#qualifier"><i>qualifiers</i></a> that are used by the
method combination facility to distinguish among <a rel=
"DEFINITION" href="26_glo_m.htm#method"><i>methods</i></a>.</p>
<p>A method object is not a function and cannot be invoked as a
function. Various mechanisms in the object system take a method
object and invoke its method function, as is the case when a
generic function is invoked. When this occurs it is said that the
method is invoked or called.</p>
<p>A method-defining form contains the <a rel="DEFINITION" href=
"26_glo_c.htm#code"><i>code</i></a> that is to be run when the
arguments to the generic function cause the method that it defines
to be invoked. When a method-defining form is evaluated, a method
object is created and one of four actions is taken:</p>
<dl>
<dt>* If a <a rel="DEFINITION" href=
"26_glo_g.htm#generic_function"><i>generic function</i></a> of the
given name already exists and if a <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>method</i></a> <a rel="DEFINITION" href=
"26_glo_o.htm#object"><i>object</i></a> already exists that agrees
with the new one on <a rel="DEFINITION" href=
"26_glo_p.htm#parameter_specializer"><i>parameter
specializers</i></a> and <a rel="DEFINITION" href=
"26_glo_q.htm#qualifier"><i>qualifiers</i></a>, the new <a rel=
"DEFINITION" href="26_glo_m.htm#method"><i>method</i></a> <a rel=
"DEFINITION" href="26_glo_o.htm#object"><i>object</i></a> replaces
the old one. For a definition of one method agreeing with another
on <a rel="DEFINITION" href=
"26_glo_p.htm#parameter_specializer"><i>parameter
specializers</i></a> and <a rel="DEFINITION" href=
"26_glo_q.htm#qualifier"><i>qualifiers</i></a>, see <a rel="CHILD"
href="07_fc.htm">Section 7.6.3 (Agreement on Parameter Specializers
and Qualifiers)</a>.<br></dt>
<dt>* If a <a rel="DEFINITION" href=
"26_glo_g.htm#generic_function"><i>generic function</i></a> of the
given name already exists and if there is no <a rel="DEFINITION"
href="26_glo_m.htm#method"><i>method</i></a> <a rel="DEFINITION"
href="26_glo_o.htm#object"><i>object</i></a> that agrees with the
new one on <a rel="DEFINITION" href=
"26_glo_p.htm#parameter_specializer"><i>parameter
specializers</i></a> and <a rel="DEFINITION" href=
"26_glo_q.htm#qualifier"><i>qualifiers</i></a>, the existing
<a rel="DEFINITION" href="26_glo_g.htm#generic_function"><i>generic
function</i></a> <a rel="DEFINITION" href=
"26_glo_o.htm#object"><i>object</i></a> is modified to contain the
new <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>method</i></a> <a rel="DEFINITION" href=
"26_glo_o.htm#object"><i>object</i></a>.<br></dt>
<dt>* If the given <a rel="DEFINITION" href=
"26_glo_n.htm#name"><i>name</i></a> names an <a rel="DEFINITION"
href="26_glo_o.htm#ordinary_function"><i>ordinary function</i></a>,
a <a rel="DEFINITION" href="26_glo_m.htm#macro"><i>macro</i></a>,
or a <a rel="DEFINITION" href=
"26_glo_s.htm#special_operator"><i>special operator</i></a>, an
error is signaled.<br></dt>
<dt>* Otherwise a <a rel="DEFINITION" href=
"26_glo_g.htm#generic_function"><i>generic function</i></a> is
created with the <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>method</i></a> specified by the <a rel=
"DEFINITION" href=
"26_glo_m.htm#method-defining_form"><i>method-defining
form</i></a>.<br></dt>
</dl>
<p>If the <a rel="DEFINITION" href=
"26_glo_l.htm#lambda_list"><i>lambda list</i></a> of a new <a rel=
"DEFINITION" href="26_glo_m.htm#method"><i>method</i></a> is not
<a rel="DEFINITION" href=
"26_glo_c.htm#congruent"><i>congruent</i></a> with the <a rel=
"DEFINITION" href="26_glo_l.htm#lambda_list"><i>lambda list</i></a>
of the <a rel="DEFINITION" href=
"26_glo_g.htm#generic_function"><i>generic function</i></a>, an
error is signaled. If a <a rel="DEFINITION" href=
"26_glo_m.htm#method-defining_operator"><i>method-defining
operator</i></a> that cannot specify <a rel="DEFINITION" href=
"26_glo_g.htm#generic_function"><i>generic function</i></a> options
creates a new <a rel="DEFINITION" href=
"26_glo_g.htm#generic_function"><i>generic function</i></a>, a
<a rel="DEFINITION" href="26_glo_l.htm#lambda_list"><i>lambda
list</i></a> for that <a rel="DEFINITION" href=
"26_glo_g.htm#generic_function"><i>generic function</i></a> is
derived from the <a rel="DEFINITION" href=
"26_glo_l.htm#lambda_list"><i>lambda list</i></a> of the <a rel=
"DEFINITION" href="26_glo_m.htm#method"><i>method</i></a> in the
<a rel="DEFINITION" href=
"26_glo_m.htm#method-defining_form"><i>method-defining form</i></a>
in such a way as to be <a rel="DEFINITION" href=
"26_glo_c.htm#congruent"><i>congruent</i></a> with it. For a
discussion of <i>congruence</i>, see <a rel="CHILD" href=
"07_fd.htm">Section 7.6.4 (Congruent Lambda-lists for all Methods
of a Generic Function)</a>.</p>
<p>Each method has a <a rel="DEFINITION" href=
"26_glo_s.htm#specialized_lambda_list"><i>specialized lambda
list</i></a>, which determines when that method can be applied. A
<a rel="DEFINITION" href=
"26_glo_s.htm#specialized_lambda_list"><i>specialized lambda
list</i></a> is like an <a rel="DEFINITION" href=
"26_glo_o.htm#ordinary_lambda_list"><i>ordinary lambda list</i></a>
except that a specialized parameter may occur instead of the name
of a required parameter. A specialized parameter is a list
<tt>(</tt><i>variable-name</i>
<i>parameter-specializer-name</i><tt>)</tt>, where
<i>parameter-specializer-name</i> is one of the following:</p>
<dl>
<dt>a <a rel="DEFINITION" href=
"26_glo_s.htm#symbol"><i>symbol</i></a><br></dt>
<dd>denotes a <a rel="DEFINITION" href=
"26_glo_p.htm#parameter_specializer"><i>parameter
specializer</i></a> which is the <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a> named by that <a rel=
"DEFINITION" href="26_glo_s.htm#symbol"><i>symbol</i></a>.</dd>
<dt>a <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a><br></dt>
<dd>denotes a <a rel="DEFINITION" href=
"26_glo_p.htm#parameter_specializer"><i>parameter
specializer</i></a> which is the <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a> itself.</dd>
<dt><tt>(eql</tt> <i>form</i><tt>)</tt><br></dt>
<dd>denotes a <a rel="DEFINITION" href=
"26_glo_p.htm#parameter_specializer"><i>parameter
specializer</i></a> which satisfies the <a rel="DEFINITION" href=
"26_glo_t.htm#type_specifier"><i>type specifier</i></a>
<tt>(eql</tt> <i>object</i><tt>)</tt>, where <i>object</i> is the
result of evaluating <i>form</i>. The form <i>form</i> is evaluated
in the lexical environment in which the method-defining form is
evaluated. Note that <i>form</i> is evaluated only once, at the
time the method is defined, not each time the generic function is
called.</dd>
</dl>
<p><a rel="DEFINITION" href=
"26_glo_p.htm#parameter_specializer_name"><i>Parameter specializer
names</i></a> are used in macros intended as the user-level
interface (<a rel="DEFINITION" href=
"m_defmet.htm#defmethod"><b>defmethod</b></a>), while <a rel=
"DEFINITION" href="26_glo_p.htm#parameter_specializer"><i>parameter
specializers</i></a> are used in the functional interface.</p>
<p>Only required parameters may be specialized, and there must be a
<a rel="DEFINITION" href=
"26_glo_p.htm#parameter_specializer"><i>parameter
specializer</i></a> for each required parameter. For notational
simplicity, if some required parameter in a <a rel="DEFINITION"
href="26_glo_s.htm#specialized_lambda_list"><i>specialized lambda
list</i></a> in a method-defining form is simply a variable name,
its <a rel="DEFINITION" href=
"26_glo_p.htm#parameter_specializer"><i>parameter
specializer</i></a> defaults to the <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a> <a rel="DEFINITION" href=
"t_t.htm#t"><b>t</b></a>.</p>
<p>Given a generic function and a set of arguments, an applicable
method is a method for that generic function whose parameter
specializers are satisfied by their corresponding arguments. The
following definition specifies what it means for a method to be
applicable and for an argument to satisfy a <a rel="DEFINITION"
href="26_glo_p.htm#parameter_specializer"><i>parameter
specializer</i></a>.</p>
<p>Let &lt;A1, ..., An&gt; be the required arguments to a generic
function in order. Let &lt;P1, ..., Pn&gt; be the <a rel=
"DEFINITION" href="26_glo_p.htm#parameter_specializer"><i>parameter
specializers</i></a> corresponding to the required parameters of
the method M in order. The method M is applicable when each Ai is
of the <a rel="DEFINITION" href="26_glo_t.htm#type"><i>type</i></a>
specified by the <a rel="DEFINITION" href=
"26_glo_t.htm#type_specifier"><i>type specifier</i></a> Pi. Because
every valid <a rel="DEFINITION" href=
"26_glo_p.htm#parameter_specializer"><i>parameter
specializer</i></a> is also a valid <a rel="DEFINITION" href=
"26_glo_t.htm#type_specifier"><i>type specifier</i></a>, the
<a rel="DEFINITION" href=
"26_glo_f.htm#function"><i>function</i></a> <a rel="DEFINITION"
href="f_typep.htm#typep"><b>typep</b></a> can be used during method
selection to determine whether an argument satisfies a <a rel=
"DEFINITION" href="26_glo_p.htm#parameter_specializer"><i>parameter
specializer</i></a>.</p>
<p>A method all of whose <a rel="DEFINITION" href=
"26_glo_p.htm#parameter_specializer"><i>parameter
specializers</i></a> are the <a rel="DEFINITION" href=
"26_glo_c.htm#class"><i>class</i></a> <a rel="DEFINITION" href=
"t_t.htm#t"><b>t</b></a> is called a <a rel="DEFINITION" href=
"26_glo_d.htm#default_method"><i>default method</i></a>; it is
always applicable but may be shadowed by a more specific
method.</p>
<p>Methods can have <a rel="DEFINITION" href=
"26_glo_q.htm#qualifier"><i>qualifiers</i></a>, which give the
method combination procedure a way to distinguish among methods. A
method that has one or more <a rel="DEFINITION" href=
"26_glo_q.htm#qualifier"><i>qualifiers</i></a> is called a <a rel=
"DEFINITION" href="26_glo_q.htm#qualified_method"><i>qualified
method</i></a>. A method with no <a rel="DEFINITION" href=
"26_glo_q.htm#qualifier"><i>qualifiers</i></a> is called an <a rel=
"DEFINITION" href="26_glo_u.htm#unqualified_method"><i>unqualified
method</i></a>. A <a rel="DEFINITION" href=
"26_glo_q.htm#qualifier"><i>qualifier</i></a> is any <a rel=
"DEFINITION" href="26_glo_n.htm#non-list"><i>non-list</i></a>. The
<a rel="DEFINITION" href=
"26_glo_q.htm#qualifier"><i>qualifiers</i></a> defined by the
<a rel="DEFINITION" href=
"26_glo_s.htm#standardized"><i>standardized</i></a> method
combination types are <a rel="DEFINITION" href=
"26_glo_s.htm#symbol"><i>symbols</i></a>.</p>
<p>In this specification, the terms "<a rel="DEFINITION" href=
"26_glo_p.htm#primary_method"><i>primary method</i></a>" and
"<a rel="DEFINITION" href=
"26_glo_a.htm#auxiliary_method"><i>auxiliary method</i></a>" are
used to partition <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>methods</i></a> within a method
combination type according to their intended use. In standard
method combination, <a rel="DEFINITION" href=
"26_glo_p.htm#primary_method"><i>primary methods</i></a> are
<a rel="DEFINITION" href=
"26_glo_u.htm#unqualified_method"><i>unqualified methods</i></a>
and <a rel="DEFINITION" href=
"26_glo_a.htm#auxiliary_method"><i>auxiliary methods</i></a> are
methods with a single <a rel="DEFINITION" href=
"26_glo_q.htm#qualifier"><i>qualifier</i></a> that is one of
<tt>:around</tt>, <tt>:before</tt>, or <tt>:after</tt>. <a rel=
"DEFINITION" href="26_glo_m.htm#method"><i>Methods</i></a> with
these <a rel="DEFINITION" href=
"26_glo_q.htm#qualifier"><i>qualifiers</i></a> are called <a rel=
"DEFINITION" href="26_glo_a.htm#around_method"><i>around
methods</i></a>, <a rel="DEFINITION" href=
"26_glo_b.htm#before_method"><i>before methods</i></a>, and <a rel=
"DEFINITION" href="26_glo_a.htm#after_method"><i>after
methods</i></a>, respectively. When a method combination type is
defined using the short form of <a rel="DEFINITION" href=
"m_defi_4.htm#define-method-combination"><b>define-method-combination</b></a>,
<a rel="DEFINITION" href="26_glo_p.htm#primary_method"><i>primary
methods</i></a> are methods qualified with the name of the type of
method combination, and auxiliary methods have the <a rel=
"DEFINITION" href="26_glo_q.htm#qualifier"><i>qualifier</i></a>
<tt>:around</tt>. Thus the terms "<a rel="DEFINITION" href=
"26_glo_p.htm#primary_method"><i>primary method</i></a>" and
"<a rel="DEFINITION" href=
"26_glo_a.htm#auxiliary_method"><i>auxiliary method</i></a>" have
only a relative definition within a given method combination
type.</p>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>7.6.3 Agreement on Parameter Specializers and Qualifiers</h2>
<p>Two <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>methods</i></a> are said to agree with
each other on <a rel="DEFINITION" href=
"26_glo_p.htm#parameter_specializer"><i>parameter
specializers</i></a> and <a rel="DEFINITION" href=
"26_glo_q.htm#qualifier"><i>qualifiers</i></a> if the following
conditions hold:</p>
<dl>
<dt>1. Both methods have the same number of required parameters.
Suppose the <a rel="DEFINITION" href=
"26_glo_p.htm#parameter_specializer"><i>parameter
specializers</i></a> of the two methods are P1,1...P1,n and
P2,1...P2,n.<br></dt>
<dt>2. For each 1&lt;=i&lt;=n, P1,i agrees with P2,i. The <a rel=
"DEFINITION" href="26_glo_p.htm#parameter_specializer"><i>parameter
specializer</i></a> P1,i agrees with P2,i if P1,i and P2,i are the
same class or if P1,i=<tt>(</tt><b>eql</b>
<i>object</i>1<tt>)</tt>, P2,i=<tt>(</tt><b>eql</b>
<i>object</i>2<tt>)</tt>, and <tt>(</tt><b>eql</b> <i>object</i>1
<i>object</i>2<tt>)</tt>. Otherwise P1,i and P2,i do not
agree.<br></dt>
<dt>3. The two <a rel="DEFINITION" href=
"26_glo_l.htm#list"><i>lists</i></a> of <a rel="DEFINITION" href=
"26_glo_q.htm#qualifier"><i>qualifiers</i></a> are the <a rel=
"DEFINITION" href="26_glo_s.htm#same"><i>same</i></a> under <a rel=
"DEFINITION" href="f_equal.htm#equal"><b>equal</b></a>.<br></dt>
</dl>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>7.6.4 Congruent Lambda-lists for all Methods of a Generic
Function</h2>
<p>These rules define the congruence of a set of <a rel=
"DEFINITION" href="26_glo_l.htm#lambda_list"><i>lambda
lists</i></a>, including the <a rel="DEFINITION" href=
"26_glo_l.htm#lambda_list"><i>lambda list</i></a> of each method
for a given generic function and the <a rel="DEFINITION" href=
"26_glo_l.htm#lambda_list"><i>lambda list</i></a> specified for the
generic function itself, if given.</p>
<dl>
<dt>1. Each <a rel="DEFINITION" href=
"26_glo_l.htm#lambda_list"><i>lambda list</i></a> must have the
same number of required parameters.<br></dt>
<dt>2. Each <a rel="DEFINITION" href=
"26_glo_l.htm#lambda_list"><i>lambda list</i></a> must have the
same number of optional parameters. Each method can supply its own
default for an optional parameter.<br></dt>
<dt>3. If any <a rel="DEFINITION" href=
"26_glo_l.htm#lambda_list"><i>lambda list</i></a> mentions
<tt>&amp;rest</tt> or <tt>&amp;key</tt>, each <a rel="DEFINITION"
href="26_glo_l.htm#lambda_list"><i>lambda list</i></a> must mention
one or both of them.<br></dt>
<dt>4. If the <a rel="DEFINITION" href=
"26_glo_g.htm#generic_function"><i>generic function</i></a> <a rel=
"DEFINITION" href="26_glo_l.htm#lambda_list"><i>lambda list</i></a>
mentions <tt>&amp;key</tt>, each method must accept all of the
keyword names mentioned after <tt>&amp;key</tt>, either by
accepting them explicitly, by specifying
<tt>&amp;allow-other-keys</tt>, or by specifying <tt>&amp;rest</tt>
but not <tt>&amp;key</tt>. Each method can accept additional
keyword arguments of its own. The checking of the validity of
keyword names is done in the generic function, not in each method.
A method is invoked as if the keyword argument pair whose name is
<tt>:allow-other-keys</tt> and whose value is <a rel="DEFINITION"
href="26_glo_t.htm#true"><i>true</i></a> were supplied, though no
such argument pair will be passed.<br></dt>
<dt>5. The use of <tt>&amp;allow-other-keys</tt> need not be
consistent across <a rel="DEFINITION" href=
"26_glo_l.htm#lambda_list"><i>lambda lists</i></a>. If
<tt>&amp;allow-other-keys</tt> is mentioned in the <a rel=
"DEFINITION" href="26_glo_l.htm#lambda_list"><i>lambda list</i></a>
of any applicable <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>method</i></a> or of the <a rel=
"DEFINITION" href="26_glo_g.htm#generic_function"><i>generic
function</i></a>, any keyword arguments may be mentioned in the
call to the <a rel="DEFINITION" href=
"26_glo_g.htm#generic_function"><i>generic
function</i></a>.<br></dt>
<dt>6. The use of <tt>&amp;aux</tt> need not be consistent across
methods.<br></dt>
<dd>If a <a rel="DEFINITION" href=
"26_glo_m.htm#method-defining_operator"><i>method-defining
operator</i></a> that cannot specify <a rel="DEFINITION" href=
"26_glo_g.htm#generic_function"><i>generic function</i></a> options
creates a <a rel="DEFINITION" href=
"26_glo_g.htm#generic_function"><i>generic function</i></a>, and if
the <a rel="DEFINITION" href="26_glo_l.htm#lambda_list"><i>lambda
list</i></a> for the method mentions keyword arguments, the <a rel=
"DEFINITION" href="26_glo_l.htm#lambda_list"><i>lambda list</i></a>
of the generic function will mention <tt>&amp;key</tt> (but no
keyword arguments).</dd>
</dl>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>7.6.5 Keyword Arguments in Generic Functions and Methods</h2>
<p>When a generic function or any of its methods mentions
<tt>&amp;key</tt> in a <a rel="DEFINITION" href=
"26_glo_l.htm#lambda_list"><i>lambda list</i></a>, the specific set
of keyword arguments accepted by the generic function varies
according to the applicable methods. The set of keyword arguments
accepted by the generic function for a particular call is the union
of the keyword arguments accepted by all applicable methods and the
keyword arguments mentioned after <tt>&amp;key</tt> in the generic
function definition, if any. A method that has <tt>&amp;rest</tt>
but not <tt>&amp;key</tt> does not affect the set of acceptable
keyword arguments. If the <a rel="DEFINITION" href=
"26_glo_l.htm#lambda_list"><i>lambda list</i></a> of any applicable
method or of the generic function definition contains
<tt>&amp;allow-other-keys</tt>, all keyword arguments are accepted
by the generic function.</p>
<p>The <a rel="DEFINITION" href=
"26_glo_l.htm#lambda_list"><i>lambda list</i></a> congruence rules
require that each method accept all of the keyword arguments
mentioned after <tt>&amp;key</tt> in the generic function
definition, by accepting them explicitly, by specifying
<tt>&amp;allow-other-keys</tt>, or by specifying <tt>&amp;rest</tt>
but not <tt>&amp;key</tt>. Each method can accept additional
keyword arguments of its own, in addition to the keyword arguments
mentioned in the generic function definition.</p>
<p>If a <a rel="DEFINITION" href=
"26_glo_g.htm#generic_function"><i>generic function</i></a> is
passed a keyword argument that no applicable method accepts, an
error should be signaled; see <a rel="CHILD" href=
"03_e.htm">Section 3.5 (Error Checking in Function Calls)</a>.</p>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>7.6.5.1 Examples of Keyword Arguments in Generic Functions and
Methods</h2>
<p>For example, suppose there are two methods defined for
<tt>width</tt> as follows:</p>
<pre>
 (defmethod width ((c character-class) &amp;key font) ...)
 
 (defmethod width ((p picture-class) &amp;key pixel-size) ...)
</pre>
<p>Assume that there are no other methods and no generic function
definition for <tt>width</tt>. The evaluation of the following form
should signal an error because the keyword argument
<tt>:pixel-size</tt> is not accepted by the applicable method.</p>
<pre>
 (width (make-instance `character-class :char #\Q) 
        :font 'baskerville :pixel-size 10)
</pre>
<p>The evaluation of the following form should signal an error.</p>
<pre>
 (width (make-instance `picture-class :glyph (glyph #\Q)) 
        :font 'baskerville :pixel-size 10)
</pre>
<p>The evaluation of the following form will not signal an error if
the class named <tt>character-picture-class</tt> is a subclass of
both <tt>picture-class</tt> and <tt>character-class</tt>.</p>
<pre>
 (width (make-instance `character-picture-class :char #\Q)
        :font 'baskerville :pixel-size 10)
</pre>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>7.6.6 Method Selection and Combination</h2>
<p>When a <a rel="DEFINITION" href=
"26_glo_g.htm#generic_function"><i>generic function</i></a> is
called with particular arguments, it must determine the code to
execute. This code is called the <a rel="DEFINITION" href=
"26_glo_e.htm#effective_method"><i>effective method</i></a> for
those <a rel="DEFINITION" href=
"26_glo_a.htm#argument"><i>arguments</i></a>. The <a rel=
"DEFINITION" href="26_glo_e.htm#effective_method"><i>effective
method</i></a> is a combination of the <a rel="DEFINITION" href=
"26_glo_a.htm#applicable_method"><i>applicable methods</i></a> in
the <a rel="DEFINITION" href=
"26_glo_g.htm#generic_function"><i>generic function</i></a> that
<a rel="DEFINITION" href="26_glo_c.htm#call"><i>calls</i></a> some
or all of the <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>methods</i></a>.</p>
<p>If a <a rel="DEFINITION" href=
"26_glo_g.htm#generic_function"><i>generic function</i></a> is
called and no <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>methods</i></a> are <a rel="DEFINITION"
href="26_glo_a.htm#applicable"><i>applicable</i></a>, the <a rel=
"DEFINITION" href="26_glo_g.htm#generic_function"><i>generic
function</i></a> <a rel="DEFINITION" href=
"f_no_app.htm#no-applicable-method"><b>no-applicable-method</b></a>
is invoked, with the <i>results</i> from that call being used as
the <i>results</i> of the call to the original <a rel="DEFINITION"
href="26_glo_g.htm#generic_function"><i>generic function</i></a>.
Calling <a rel="DEFINITION" href=
"f_no_app.htm#no-applicable-method"><b>no-applicable-method</b></a>
takes precedence over checking for acceptable keyword arguments;
see <a rel="CHILD" href="07_fe.htm">Section 7.6.5 (Keyword
Arguments in Generic Functions and Methods)</a>.</p>
<p>When the <a rel="DEFINITION" href=
"26_glo_e.htm#effective_method"><i>effective method</i></a> has
been determined, it is invoked with the same <a rel="DEFINITION"
href="26_glo_a.htm#argument"><i>arguments</i></a> as were passed to
the <a rel="DEFINITION" href=
"26_glo_g.htm#generic_function"><i>generic function</i></a>.
Whatever <a rel="DEFINITION" href=
"26_glo_v.htm#value"><i>values</i></a> it returns are returned as
the <a rel="DEFINITION" href="26_glo_v.htm#value"><i>values</i></a>
of the <a rel="DEFINITION" href=
"26_glo_g.htm#generic_function"><i>generic function</i></a>.</p>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>7.6.6.1 Determining the Effective Method</h2>
<p>The effective method is determined by the following three-step
procedure:</p>
<dl>
<dt>1. Select the applicable methods.<br></dt>
<dt>2. Sort the applicable methods by precedence order, putting the
most specific method first.<br></dt>
<dt>3. Apply method combination to the sorted list of applicable
methods, producing the effective method.<br></dt>
</dl>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>7.6.6.1.1 Selecting the Applicable Methods</h2>
<p>This step is described in <a rel="CHILD" href=
"07_fb.htm">Section 7.6.2 (Introduction to Methods)</a>.</p>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>7.6.6.1.2 Sorting the Applicable Methods by Precedence
Order</h2>
<p>To compare the precedence of two methods, their <a rel=
"DEFINITION" href="26_glo_p.htm#parameter_specializer"><i>parameter
specializers</i></a> are examined in order. The default examination
order is from left to right, but an alternative order may be
specified by the <tt>:argument-precedence-order</tt> option to
<a rel="DEFINITION" href=
"m_defgen.htm#defgeneric"><b>defgeneric</b></a> or to any of the
other operators that specify generic function options.</p>
<p>The corresponding <a rel="DEFINITION" href=
"26_glo_p.htm#parameter_specializer"><i>parameter
specializers</i></a> from each method are compared. When a pair of
<a rel="DEFINITION" href=
"26_glo_p.htm#parameter_specializer"><i>parameter
specializers</i></a> agree, the next pair are compared for
agreement. If all corresponding parameter specializers agree, the
two methods must have different <a rel="DEFINITION" href=
"26_glo_q.htm#qualifier"><i>qualifiers</i></a>; in this case,
either method can be selected to precede the other. For information
about agreement, see <a rel="CHILD" href="07_fc.htm">Section 7.6.3
(Agreement on Parameter Specializers and Qualifiers)</a>.</p>
<p>If some corresponding <a rel="DEFINITION" href=
"26_glo_p.htm#parameter_specializer"><i>parameter
specializers</i></a> do not agree, the first pair of <a rel=
"DEFINITION" href="26_glo_p.htm#parameter_specializer"><i>parameter
specializers</i></a> that do not agree determines the precedence.
If both <a rel="DEFINITION" href=
"26_glo_p.htm#parameter_specializer"><i>parameter
specializers</i></a> are classes, the more specific of the two
methods is the method whose <a rel="DEFINITION" href=
"26_glo_p.htm#parameter_specializer"><i>parameter
specializer</i></a> appears earlier in the <a rel="DEFINITION"
href="26_glo_c.htm#class_precedence_list"><i>class precedence
list</i></a> of the corresponding argument. Because of the way in
which the set of applicable methods is chosen, the <a rel=
"DEFINITION" href="26_glo_p.htm#parameter_specializer"><i>parameter
specializers</i></a> are guaranteed to be present in the class
precedence list of the class of the argument.</p>
<p>If just one of a pair of corresponding <a rel="DEFINITION" href=
"26_glo_p.htm#parameter_specializer"><i>parameter
specializers</i></a> is <tt>(eql</tt> <i>object</i><tt>)</tt>, the
<a rel="DEFINITION" href="26_glo_m.htm#method"><i>method</i></a>
with that <a rel="DEFINITION" href=
"26_glo_p.htm#parameter_specializer"><i>parameter
specializer</i></a> precedes the other <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>method</i></a>. If both <a rel=
"DEFINITION" href="26_glo_p.htm#parameter_specializer"><i>parameter
specializers</i></a> are <a rel="DEFINITION" href=
"f_eql.htm#eql"><b>eql</b></a> <a rel="DEFINITION" href=
"26_glo_e.htm#expression"><i>expressions</i></a>, the specializers
must agree (otherwise the two <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>methods</i></a> would not both have been
applicable to this argument).</p>
<p>The resulting list of <a rel="DEFINITION" href=
"26_glo_a.htm#applicable_method"><i>applicable methods</i></a> has
the most specific <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>method</i></a> first and the least
specific <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>method</i></a> last.</p>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>7.6.6.1.3 Applying method combination to the sorted list of
applicable methods</h2>
<p>In the simple case---if standard method combination is used and
all applicable methods are primary methods---the effective method
is the most specific method. That method can call the next most
specific method by using the <a rel="DEFINITION" href=
"26_glo_f.htm#function"><i>function</i></a> <a rel="DEFINITION"
href="f_call_n.htm#call-next-method"><b>call-next-method</b></a>.
The method that <a rel="DEFINITION" href=
"f_call_n.htm#call-next-method"><b>call-next-method</b></a> will
call is referred to as the <a rel="DEFINITION" href=
"26_glo_n.htm#next_method"><i>next method</i></a>. The predicate
<a rel="DEFINITION" href=
"f_next_m.htm#next-method-p"><b>next-method-p</b></a> tests whether
a next method exists. If <a rel="DEFINITION" href=
"f_call_n.htm#call-next-method"><b>call-next-method</b></a> is
called and there is no next most specific method, the generic
function <a rel="DEFINITION" href=
"f_no_nex.htm#no-next-method"><b>no-next-method</b></a> is
invoked.</p>
<p>In general, the effective method is some combination of the
applicable methods. It is described by a <a rel="DEFINITION" href=
"26_glo_f.htm#form"><i>form</i></a> that contains calls to some or
all of the applicable methods, returns the value or values that
will be returned as the value or values of the generic function,
and optionally makes some of the methods accessible by means of
<a rel="DEFINITION" href=
"f_call_n.htm#call-next-method"><b>call-next-method</b></a>.</p>
<p>The role of each method in the effective method is determined by
its <a rel="DEFINITION" href=
"26_glo_q.htm#qualifier"><i>qualifiers</i></a> and the specificity
of the method. A <a rel="DEFINITION" href=
"26_glo_q.htm#qualifier"><i>qualifier</i></a> serves to mark a
method, and the meaning of a <a rel="DEFINITION" href=
"26_glo_q.htm#qualifier"><i>qualifier</i></a> is determined by the
way that these marks are used by this step of the procedure. If an
applicable method has an unrecognized <a rel="DEFINITION" href=
"26_glo_q.htm#qualifier"><i>qualifier</i></a>, this step signals an
error and does not include that method in the effective method.</p>
<p>When standard method combination is used together with qualified
methods, the effective method is produced as described in <a rel=
"CHILD" href="07_ffb.htm">Section 7.6.6.2 (Standard Method
Combination)</a>.</p>
<p>Another type of method combination can be specified by using the
<tt>:method-combination</tt> option of <a rel="DEFINITION" href=
"m_defgen.htm#defgeneric"><b>defgeneric</b></a> or of any of the
other operators that specify generic function options. In this way
this step of the procedure can be customized.</p>
<p>New types of method combination can be defined by using the
<a rel="DEFINITION" href=
"m_defi_4.htm#define-method-combination"><b>define-method-combination</b></a>
<a rel="DEFINITION" href="26_glo_m.htm#macro"><i>macro</i></a>.</p>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>7.6.6.2 Standard Method Combination</h2>
<a name="standard" id="standard"></a>
<p>Standard method combination is supported by the <a rel=
"DEFINITION" href="26_glo_c.htm#class"><i>class</i></a> <a rel=
"DEFINITION" href=
"t_std_ge.htm#standard-generic-function"><b>standard-generic-function</b></a>.
It is used if no other type of method combination is specified or
if the built-in method combination type <a rel="DEFINITION" href=
"#standard"><b>standard</b></a> is specified.</p>
<p>Primary methods define the main action of the effective method,
while auxiliary methods modify that action in one of three ways. A
primary method has no method <a rel="DEFINITION" href=
"26_glo_q.htm#qualifier"><i>qualifiers</i></a>.</p>
<p>An auxiliary method is a method whose <a rel="DEFINITION" href=
"26_glo_q.htm#qualifier"><i>qualifier</i></a> is <tt>:before</tt>,
<tt>:after</tt>, or <tt>:around</tt>. Standard method combination
allows no more than one <a rel="DEFINITION" href=
"26_glo_q.htm#qualifier"><i>qualifier</i></a> per method; if a
method definition specifies more than one <a rel="DEFINITION" href=
"26_glo_q.htm#qualifier"><i>qualifier</i></a> per method, an error
is signaled.</p>
<dl>
<dt>* A <a rel="DEFINITION" href=
"26_glo_b.htm#before_method"><i>before method</i></a> has the
keyword <tt>:before</tt> as its only <a rel="DEFINITION" href=
"26_glo_q.htm#qualifier"><i>qualifier</i></a>. A <a rel=
"DEFINITION" href="26_glo_b.htm#before_method"><i>before
method</i></a> specifies <a rel="DEFINITION" href=
"26_glo_c.htm#code"><i>code</i></a> that is to be run before any
<a rel="DEFINITION" href="26_glo_p.htm#primary_method"><i>primary
methods</i></a>.<br></dt>
<dt>* An <a rel="DEFINITION" href=
"26_glo_a.htm#after_method"><i>after method</i></a> has the keyword
<tt>:after</tt> as its only <a rel="DEFINITION" href=
"26_glo_q.htm#qualifier"><i>qualifier</i></a>. An <a rel=
"DEFINITION" href="26_glo_a.htm#after_method"><i>after
method</i></a> specifies <a rel="DEFINITION" href=
"26_glo_c.htm#code"><i>code</i></a> that is to be run after <a rel=
"DEFINITION" href="26_glo_p.htm#primary_method"><i>primary
methods</i></a>.<br></dt>
<dt>* An <a rel="DEFINITION" href=
"26_glo_a.htm#around_method"><i>around method</i></a> has the
keyword <tt>:around</tt> as its only <a rel="DEFINITION" href=
"26_glo_q.htm#qualifier"><i>qualifier</i></a>. An <a rel=
"DEFINITION" href="26_glo_a.htm#around_method"><i>around
method</i></a> specifies <a rel="DEFINITION" href=
"26_glo_c.htm#code"><i>code</i></a> that is to be run instead of
other <a rel="DEFINITION" href=
"26_glo_a.htm#applicable_method"><i>applicable methods</i></a>, but
which might contain explicit <a rel="DEFINITION" href=
"26_glo_c.htm#code"><i>code</i></a> which calls some of those
<i>shadowed</i> <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>methods</i></a> (via <a rel="DEFINITION"
href=
"f_call_n.htm#call-next-method"><b>call-next-method</b></a>).<br></dt>
</dl>
<p>The semantics of standard method combination is as follows:</p>
<dl>
<dt>* If there are any <a rel="DEFINITION" href=
"26_glo_a.htm#around_method"><i>around methods</i></a>, the most
specific <a rel="DEFINITION" href=
"26_glo_a.htm#around_method"><i>around method</i></a> is called. It
supplies the value or values of the generic function.<br></dt>
<dt>* Inside the body of an <a rel="DEFINITION" href=
"26_glo_a.htm#around_method"><i>around method</i></a>, <a rel=
"DEFINITION" href=
"f_call_n.htm#call-next-method"><b>call-next-method</b></a> can be
used to call the <a rel="DEFINITION" href=
"26_glo_n.htm#next_method"><i>next method</i></a>. When the next
method returns, the <a rel="DEFINITION" href=
"26_glo_a.htm#around_method"><i>around method</i></a> can execute
more code, perhaps based on the returned value or values. The
<a rel="DEFINITION" href="26_glo_g.htm#generic_function"><i>generic
function</i></a> <a rel="DEFINITION" href=
"f_no_nex.htm#no-next-method"><b>no-next-method</b></a> is invoked
if <a rel="DEFINITION" href=
"f_call_n.htm#call-next-method"><b>call-next-method</b></a> is used
and there is no <a rel="DEFINITION" href=
"26_glo_a.htm#applicable_method"><i>applicable method</i></a> to
call. The <a rel="DEFINITION" href=
"26_glo_f.htm#function"><i>function</i></a> <a rel="DEFINITION"
href="f_next_m.htm#next-method-p"><b>next-method-p</b></a> may be
used to determine whether a <a rel="DEFINITION" href=
"26_glo_n.htm#next_method"><i>next method</i></a> exists.<br></dt>
<dt>* If an <a rel="DEFINITION" href=
"26_glo_a.htm#around_method"><i>around method</i></a> invokes
<a rel="DEFINITION" href=
"f_call_n.htm#call-next-method"><b>call-next-method</b></a>, the
next most specific <a rel="DEFINITION" href=
"26_glo_a.htm#around_method"><i>around method</i></a> is called, if
one is applicable. If there are no <a rel="DEFINITION" href=
"26_glo_a.htm#around_method"><i>around methods</i></a> or if
<a rel="DEFINITION" href=
"f_call_n.htm#call-next-method"><b>call-next-method</b></a> is
called by the least specific <a rel="DEFINITION" href=
"26_glo_a.htm#around_method"><i>around method</i></a>, the other
methods are called as follows:<br></dt>
<dd>
<dl>
<dt>-- All the <a rel="DEFINITION" href=
"26_glo_b.htm#before_method"><i>before methods</i></a> are called,
in most-specific-first order. Their values are ignored. An error is
signaled if <a rel="DEFINITION" href=
"f_call_n.htm#call-next-method"><b>call-next-method</b></a> is used
in a <a rel="DEFINITION" href=
"26_glo_b.htm#before_method"><i>before method</i></a>.<br></dt>
<dt>-- The most specific primary method is called. Inside the body
of a primary method, <a rel="DEFINITION" href=
"f_call_n.htm#call-next-method"><b>call-next-method</b></a> may be
used to call the next most specific primary method. When that
method returns, the previous primary method can execute more code,
perhaps based on the returned value or values. The generic function
<a rel="DEFINITION" href=
"f_no_nex.htm#no-next-method"><b>no-next-method</b></a> is invoked
if <a rel="DEFINITION" href=
"f_call_n.htm#call-next-method"><b>call-next-method</b></a> is used
and there are no more applicable primary methods. The <a rel=
"DEFINITION" href="26_glo_f.htm#function"><i>function</i></a>
<a rel="DEFINITION" href=
"f_next_m.htm#next-method-p"><b>next-method-p</b></a> may be used
to determine whether a <a rel="DEFINITION" href=
"26_glo_n.htm#next_method"><i>next method</i></a> exists. If
<a rel="DEFINITION" href=
"f_call_n.htm#call-next-method"><b>call-next-method</b></a> is not
used, only the most specific <a rel="DEFINITION" href=
"26_glo_p.htm#primary_method"><i>primary method</i></a> is
called.<br></dt>
<dt>-- All the <a rel="DEFINITION" href=
"26_glo_a.htm#after_method"><i>after methods</i></a> are called in
most-specific-last order. Their values are ignored. An error is
signaled if <a rel="DEFINITION" href=
"f_call_n.htm#call-next-method"><b>call-next-method</b></a> is used
in an <a rel="DEFINITION" href="26_glo_a.htm#after_method"><i>after
method</i></a>.<br></dt>
</dl>
</dd>
<dt>* If no <a rel="DEFINITION" href=
"26_glo_a.htm#around_method"><i>around methods</i></a> were
invoked, the most specific primary method supplies the value or
values returned by the generic function. The value or values
returned by the invocation of <a rel="DEFINITION" href=
"f_call_n.htm#call-next-method"><b>call-next-method</b></a> in the
least specific <a rel="DEFINITION" href=
"26_glo_a.htm#around_method"><i>around method</i></a> are those
returned by the most specific primary method.<br></dt>
</dl>
<p>In standard method combination, if there is an applicable method
but no applicable primary method, an error is signaled.</p>
<p>The <a rel="DEFINITION" href=
"26_glo_b.htm#before_method"><i>before methods</i></a> are run in
most-specific-first order while the <a rel="DEFINITION" href=
"26_glo_a.htm#after_method"><i>after methods</i></a> are run in
least-specific-first order. The design rationale for this
difference can be illustrated with an example. Suppose class C1
modifies the behavior of its superclass, C2, by adding <a rel=
"DEFINITION" href="26_glo_b.htm#before_method"><i>before
methods</i></a> and <a rel="DEFINITION" href=
"26_glo_a.htm#after_method"><i>after methods</i></a>. Whether the
behavior of the class C2 is defined directly by methods on C2 or is
inherited from its superclasses does not affect the relative order
of invocation of methods on instances of the class C1. Class C1's
<a rel="DEFINITION" href="26_glo_b.htm#before_method"><i>before
method</i></a> runs before all of class C2's methods. Class C1's
<a rel="DEFINITION" href="26_glo_a.htm#after_method"><i>after
method</i></a> runs after all of class C2's methods.</p>
<p>By contrast, all <a rel="DEFINITION" href=
"26_glo_a.htm#around_method"><i>around methods</i></a> run before
any other methods run. Thus a less specific <a rel="DEFINITION"
href="26_glo_a.htm#around_method"><i>around method</i></a> runs
before a more specific primary method.</p>
<p>If only primary methods are used and if <a rel="DEFINITION"
href="f_call_n.htm#call-next-method"><b>call-next-method</b></a> is
not used, only the most specific method is invoked; that is, more
specific methods shadow more general ones.</p>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>7.6.6.3 Declarative Method Combination</h2>
<p>The macro <a rel="DEFINITION" href=
"m_defi_4.htm#define-method-combination"><b>define-method-combination</b></a>
defines new forms of method combination. It provides a mechanism
for customizing the production of the effective method. The default
procedure for producing an effective method is described in <a rel=
"CHILD" href="07_ffa.htm">Section 7.6.6.1 (Determining the
Effective Method)</a>. There are two forms of <a rel="DEFINITION"
href=
"m_defi_4.htm#define-method-combination"><b>define-method-combination</b></a>.
The short form is a simple facility while the long form is more
powerful and more verbose. The long form resembles <a rel=
"DEFINITION" href="m_defmac.htm#defmacro"><b>defmacro</b></a> in
that the body is an expression that computes a Lisp form; it
provides mechanisms for implementing arbitrary control structures
within method combination and for arbitrary processing of method
<a rel="DEFINITION" href=
"26_glo_q.htm#qualifier"><i>qualifiers</i></a>.</p>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>7.6.6.4 Built-in Method Combination Types</h2>
<p>The object system provides a set of built-in method combination
types. To specify that a generic function is to use one of these
method combination types, the name of the method combination type
is given as the argument to the <tt>:method-combination</tt> option
to <a rel="DEFINITION" href=
"m_defgen.htm#defgeneric"><b>defgeneric</b></a> or to the
<tt>:method-combination</tt> option to any of the other operators
that specify generic function options.</p>
<p>The names of the built-in method combination types are listed in
the next figure.</p>
<pre>
<a rel="DEFINITION" href="a_pl.htm#PL">+</a>    <a rel="DEFINITION"
href="f_append.htm#append">append</a>  <a rel="DEFINITION" href=
"f_max_m.htm#max">max</a>  <a rel="DEFINITION" href=
"f_nconc.htm#nconc">nconc</a>  <a rel="DEFINITION" href=
"s_progn.htm#progn">progn</a>     
<a rel="DEFINITION" href="a_and.htm#and">and</a>  <a rel=
"DEFINITION" href="a_list.htm#list">list</a>    <a rel="DEFINITION"
href="f_max_m.htm#min">min</a>  <a rel="DEFINITION" href=
"a_or.htm#or">or</a>     <a rel="DEFINITION" href=
"07_ffb.htm#standard">standard</a>  
</pre>
<p><b>Figure 7-2. Built-in Method Combination Types</b></p>
<p>The semantics of the <a rel="DEFINITION" href=
"07_ffb.htm#standard"><b>standard</b></a> built-in method
combination type is described in <a rel="CHILD" href=
"07_ffb.htm">Section 7.6.6.2 (Standard Method Combination)</a>. The
other built-in method combination types are called simple built-in
method combination types.</p>
<p>The simple built-in method combination types act as though they
were defined by the short form of <a rel="DEFINITION" href=
"m_defi_4.htm#define-method-combination"><b>define-method-combination</b></a>.
They recognize two roles for <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>methods</i></a>:</p>
<dl>
<dt>* An <a rel="DEFINITION" href=
"26_glo_a.htm#around_method"><i>around method</i></a> has the
keyword symbol <tt>:around</tt> as its sole <a rel="DEFINITION"
href="26_glo_q.htm#qualifier"><i>qualifier</i></a>. The meaning of
<tt>:around</tt> <a rel="DEFINITION" href=
"26_glo_m.htm#method"><i>methods</i></a> is the same as in standard
method combination. Use of the functions <a rel="DEFINITION" href=
"f_call_n.htm#call-next-method"><b>call-next-method</b></a> and
<a rel="DEFINITION" href=
"f_next_m.htm#next-method-p"><b>next-method-p</b></a> is supported
in <a rel="DEFINITION" href="26_glo_a.htm#around_method"><i>around
methods</i></a>.<br></dt>
<dt>* A primary method has the name of the method combination type
as its sole <a rel="DEFINITION" href=
"26_glo_q.htm#qualifier"><i>qualifier</i></a>. For example, the
built-in method combination type <tt>and</tt> recognizes methods
whose sole <a rel="DEFINITION" href=
"26_glo_q.htm#qualifier"><i>qualifier</i></a> is <tt>and</tt>;
these are primary methods. Use of the functions <a rel="DEFINITION"
href="f_call_n.htm#call-next-method"><b>call-next-method</b></a>
and <a rel="DEFINITION" href=
"f_next_m.htm#next-method-p"><b>next-method-p</b></a> is not
supported in <a rel="DEFINITION" href=
"26_glo_p.htm#primary_method"><i>primary methods</i></a>.<br></dt>
</dl>
<p>The semantics of the simple built-in method combination types is
as follows:</p>
<dl>
<dt>* If there are any <a rel="DEFINITION" href=
"26_glo_a.htm#around_method"><i>around methods</i></a>, the most
specific <a rel="DEFINITION" href=
"26_glo_a.htm#around_method"><i>around method</i></a> is called. It
supplies the value or values of the <a rel="DEFINITION" href=
"26_glo_g.htm#generic_function"><i>generic
function</i></a>.<br></dt>
<dt>* Inside the body of an <a rel="DEFINITION" href=
"26_glo_a.htm#around_method"><i>around method</i></a>, the function
<a rel="DEFINITION" href=
"f_call_n.htm#call-next-method"><b>call-next-method</b></a> can be
used to call the <a rel="DEFINITION" href=
"26_glo_n.htm#next_method"><i>next method</i></a>. The <a rel=
"DEFINITION" href="26_glo_g.htm#generic_function"><i>generic
function</i></a> <a rel="DEFINITION" href=
"f_no_nex.htm#no-next-method"><b>no-next-method</b></a> is invoked
if <a rel="DEFINITION" href=
"f_call_n.htm#call-next-method"><b>call-next-method</b></a> is used
and there is no applicable method to call. The <a rel="DEFINITION"
href="26_glo_f.htm#function"><i>function</i></a> <a rel=
"DEFINITION" href=
"f_next_m.htm#next-method-p"><b>next-method-p</b></a> may be used
to determine whether a <a rel="DEFINITION" href=
"26_glo_n.htm#next_method"><i>next method</i></a> exists. When the
<a rel="DEFINITION" href="26_glo_n.htm#next_method"><i>next
method</i></a> returns, the <a rel="DEFINITION" href=
"26_glo_a.htm#around_method"><i>around method</i></a> can execute
more code, perhaps based on the returned value or values.<br></dt>
<dt>* If an <a rel="DEFINITION" href=
"26_glo_a.htm#around_method"><i>around method</i></a> invokes
<a rel="DEFINITION" href=
"f_call_n.htm#call-next-method"><b>call-next-method</b></a>, the
next most specific <a rel="DEFINITION" href=
"26_glo_a.htm#around_method"><i>around method</i></a> is called, if
one is applicable. If there are no <a rel="DEFINITION" href=
"26_glo_a.htm#around_method"><i>around methods</i></a> or if
<a rel="DEFINITION" href=
"f_call_n.htm#call-next-method"><b>call-next-method</b></a> is
called by the least specific <a rel="DEFINITION" href=
"26_glo_a.htm#around_method"><i>around method</i></a>, a Lisp form
derived from the name of the built-in method combination type and
from the list of applicable primary methods is evaluated to produce
the value of the generic function. Suppose the name of the method
combination type is <i>operator</i> and the call to the generic
function is of the form<br></dt>
<dd>
<p>(<i>generic-function</i> a1...an)</p>
</dd>
<dt>Let M1,...,Mk be the applicable primary methods in order; then
the derived Lisp form is<br></dt>
<dd>
<p>(<i>operator</i> &lt;M1 a1...an&gt;...&lt;Mk a1...an&gt;)</p>
</dd>
<dt>If the expression &lt;Mi a1...an&gt; is evaluated, the method
Mi will be applied to the arguments a1...an. For example, if
<i>operator</i> is <tt>or</tt>, the expression &lt;Mi a1...an&gt;
is evaluated only if &lt;Mj a1...an&gt;, 1&lt;=j&lt;i, returned
<tt>nil</tt>.<br></dt>
<dt>The default order for the primary methods is
<tt>:most-specific-first</tt>. However, the order can be reversed
by supplying <tt>:most-specific-last</tt> as the second argument to
the <tt>:method-combination</tt> option.<br></dt>
</dl>
<p>The simple built-in method combination types require exactly one
<a rel="DEFINITION" href=
"26_glo_q.htm#qualifier"><i>qualifier</i></a> per method. An error
is signaled if there are applicable methods with no <a rel=
"DEFINITION" href="26_glo_q.htm#qualifier"><i>qualifiers</i></a> or
with <a rel="DEFINITION" href=
"26_glo_q.htm#qualifier"><i>qualifiers</i></a> that are not
supported by the method combination type. An error is signaled if
there are applicable <a rel="DEFINITION" href=
"26_glo_a.htm#around_method"><i>around methods</i></a> and no
applicable primary methods.</p>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>7.6.7 Inheritance of Methods</h2>
<p>A subclass inherits methods in the sense that any method
applicable to all instances of a class is also applicable to all
instances of any subclass of that class.</p>
<p>The inheritance of methods acts the same way regardless of which
of the <a rel="DEFINITION" href=
"26_glo_m.htm#method-defining_operator"><i>method-defining
operators</i></a> created the methods.</p>
<p>The inheritance of methods is described in detail in <a rel=
"CHILD" href="07_ff.htm">Section 7.6.6 (Method Selection and
Combination)</a>.</p>
</body>
</html>
