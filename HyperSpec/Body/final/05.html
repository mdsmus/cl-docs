<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content=
"HTML Tidy for Linux/x86 (vers 12 April 2005), see www.w3.org">
<title>CLHS: Chapter 5</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="e_smp_tp.htm">
<link rel="UP" href="../Front/Contents.htm">
<link rel="NEXT" href="05_a.htm">
<title>CLHS: Section 5.1</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="05_.htm">
<link rel="UP" href="05_.htm">
<link rel="NEXT" href="05_aa.htm">
<title>CLHS: Section 5.1.1</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="05_a.htm">
<link rel="UP" href="05_a.htm">
<link rel="NEXT" href="05_aaa.htm">
<title>CLHS: Section 5.1.1.1</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="05_aa.htm">
<link rel="UP" href="05_aa.htm">
<link rel="NEXT" href="05_aaaa.htm">
<title>CLHS: Section 5.1.1.1.1</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="05_aaa.htm">
<link rel="UP" href="05_aaa.htm">
<link rel="NEXT" href="05_aab.htm">
<title>CLHS: Section 5.1.1.2</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="05_aaaa.htm">
<link rel="UP" href="05_aa.htm">
<link rel="NEXT" href="05_aaba.htm">
<title>CLHS: Section 5.1.1.2.1</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="05_aab.htm">
<link rel="UP" href="05_aab.htm">
<link rel="NEXT" href="05_ab.htm">
<title>CLHS: Section 5.1.2</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="05_aaba.htm">
<link rel="UP" href="05_a.htm">
<link rel="NEXT" href="05_aba.htm">
<title>CLHS: Section 5.1.2.1</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="05_ab.htm">
<link rel="UP" href="05_ab.htm">
<link rel="NEXT" href="05_abb.htm">
<title>CLHS: Section 5.1.2.2</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="05_aba.htm">
<link rel="UP" href="05_ab.htm">
<link rel="NEXT" href="05_abc.htm">
<title>CLHS: Section 5.1.2.3</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="05_abb.htm">
<link rel="UP" href="05_ab.htm">
<link rel="NEXT" href="05_abd.htm">
<title>CLHS: Section 5.1.2.4</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="05_abc.htm">
<link rel="UP" href="05_ab.htm">
<link rel="NEXT" href="05_abe.htm">
<title>CLHS: Section 5.1.2.5</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="05_abd.htm">
<link rel="UP" href="05_ab.htm">
<link rel="NEXT" href="05_abf.htm">
<title>CLHS: Section 5.1.2.6</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="05_abe.htm">
<link rel="UP" href="05_ab.htm">
<link rel="NEXT" href="05_abg.htm">
<title>CLHS: Section 5.1.2.7</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="05_abf.htm">
<link rel="UP" href="05_ab.htm">
<link rel="NEXT" href="05_abh.htm">
<title>CLHS: Section 5.1.2.8</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="05_abg.htm">
<link rel="UP" href="05_ab.htm">
<link rel="NEXT" href="05_abi.htm">
<title>CLHS: Section 5.1.2.9</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="05_abh.htm">
<link rel="UP" href="05_ab.htm">
<link rel="NEXT" href="05_ac.htm">
<title>CLHS: Section 5.1.3</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="05_abi.htm">
<link rel="UP" href="05_a.htm">
<link rel="NEXT" href="05_b.htm">
<title>CLHS: Section 5.2</title>
<link href="../Data/clhs.css" rel="stylesheet" type="text/css">
<meta http-equiv="Author" content="Kent M. Pitman">
<meta http-equiv="Organization" content="LispWorks Ltd.">
<link rel="TOP" href="../Front/index.htm">
<link rel="COPYRIGHT" href="../Front/Help.htm#Legal">
<link rel="DISCLAIMER" href="../Front/Help.htm#Disclaimer">
<link rel="PREV" href="05_ac.htm">
<link rel="UP" href="05_.htm">
<link rel="NEXT" href="c_data_a.htm">
</head>
<body>
<p><a name="chapfive" id="chapfive"></a><a name=
"dataandcontrolflow" id="dataandcontrolflow"></a></p>
<h2>5. Data and Control Flow</h2>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>5.1 Generalized Reference</h2>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>5.1.1 Overview of Places and Generalized Reference</h2>
<p>A <a rel="DEFINITION" href=
"26_glo_g.htm#generalized_reference"><i>generalized
reference</i></a> is the use of a <a rel="DEFINITION" href=
"26_glo_f.htm#form"><i>form</i></a>, sometimes called a <a rel=
"DEFINITION" href="26_glo_p.htm#place"><i>place</i></a>, as if it
were a <a rel="DEFINITION" href=
"26_glo_v.htm#variable"><i>variable</i></a> that could be read and
written. The <a rel="DEFINITION" href=
"26_glo_v.htm#value"><i>value</i></a> of a <a rel="DEFINITION"
href="26_glo_p.htm#place"><i>place</i></a> is the <a rel=
"DEFINITION" href="26_glo_o.htm#object"><i>object</i></a> to which
the <a rel="DEFINITION" href="26_glo_p.htm#place"><i>place</i></a>
<a rel="DEFINITION" href="26_glo_f.htm#form"><i>form</i></a>
evaluates. The <a rel="DEFINITION" href=
"26_glo_v.htm#value"><i>value</i></a> of a <a rel="DEFINITION"
href="26_glo_p.htm#place"><i>place</i></a> can be changed by using
<a rel="DEFINITION" href="m_setf_.htm#setf"><b>setf</b></a>. The
concept of binding a <a rel="DEFINITION" href=
"26_glo_p.htm#place"><i>place</i></a> is not defined in Common
Lisp, but an <a rel="DEFINITION" href=
"26_glo_i.htm#implementation"><i>implementation</i></a> is
permitted to extend the language by defining this concept.</p>
<p>The next figure contains examples of the use of <a rel=
"DEFINITION" href="m_setf_.htm#setf"><b>setf</b></a>. Note that the
values returned by evaluating the <a rel="DEFINITION" href=
"26_glo_f.htm#form"><i>forms</i></a> in column two are not
necessarily the same as those obtained by evaluating the <a rel=
"DEFINITION" href="26_glo_f.htm#form"><i>forms</i></a> in column
three. In general, the exact <a rel="DEFINITION" href=
"26_glo_m.htm#macro_expansion"><i>macro expansion</i></a> of a
<a rel="DEFINITION" href="m_setf_.htm#setf"><b>setf</b></a> <a rel=
"DEFINITION" href="26_glo_f.htm#form"><i>form</i></a> is not
guaranteed and can even be <a rel="DEFINITION" href=
"26_glo_i.htm#implementation-dependent"><i>implementation-dependent</i></a>;
all that is guaranteed is that the expansion is an update form that
works for that particular <a rel="DEFINITION" href=
"26_glo_i.htm#implementation"><i>implementation</i></a>, that the
left-to-right evaluation of <a rel="DEFINITION" href=
"26_glo_s.htm#subform"><i>subforms</i></a> is preserved, and that
the ultimate result of evaluating <a rel="DEFINITION" href=
"m_setf_.htm#setf"><b>setf</b></a> is the value or values being
stored.</p>
<pre>
Access function   Update Function   Update using <a rel=
"DEFINITION" href="m_setf_.htm#setf">setf</a>              
x                 (setq x datum)    (setf x datum)                 
(car x)           (rplaca x datum)  (setf (car x) datum)           
(symbol-value x)  (set x datum)     (setf (symbol-value x) datum)  
</pre>
<p><b>Figure 5-1. Examples of setf</b></p>
<p>The next figure shows <a rel="DEFINITION" href=
"26_glo_o.htm#operator"><i>operators</i></a> relating to <a rel=
"DEFINITION" href="26_glo_p.htm#place"><i>places</i></a> and
<a rel="DEFINITION" href=
"26_glo_g.htm#generalized_reference"><i>generalized
reference</i></a>.</p>
<pre>
<a rel="DEFINITION" href=
"m_assert.htm#assert">assert</a>                <a rel="DEFINITION"
href="m_defset.htm#defsetf">defsetf</a>             <a rel=
"DEFINITION" href="m_push.htm#push">push</a>     
<a rel="DEFINITION" href=
"m_case_.htm#ccase">ccase</a>                 <a rel="DEFINITION"
href=
"f_get_se.htm#get-setf-expansion">get-setf-expansion</a>  <a rel=
"DEFINITION" href="m_remf.htm#remf">remf</a>     
<a rel="DEFINITION" href=
"m_tpcase.htm#ctypecase">ctypecase</a>             <a rel=
"DEFINITION" href="f_getf.htm#getf">getf</a>                <a rel=
"DEFINITION" href="m_rotate.htm#rotatef">rotatef</a>  
<a rel="DEFINITION" href=
"m_incf_.htm#decf">decf</a>                  <a rel="DEFINITION"
href="m_incf_.htm#incf">incf</a>                <a rel="DEFINITION"
href="a_setf.htm#setf">setf</a>     
<a rel="DEFINITION" href=
"m_defi_2.htm#define-modify-macro">define-modify-macro</a>   <a rel="DEFINITION"
href="m_pop.htm#pop">pop</a>                 <a rel="DEFINITION"
href="m_shiftf.htm#shiftf">shiftf</a>   
<a rel="DEFINITION" href=
"m_defi_3.htm#define-setf-expander">define-setf-expander</a>  <a rel="DEFINITION"
href="m_setf_.htm#psetf">psetf</a>                        
</pre>
<p><b>Figure 5-2. Operators relating to places and generalized
reference.</b></p>
<p>Some of the <a rel="DEFINITION" href=
"26_glo_o.htm#operator"><i>operators</i></a> above manipulate
<a rel="DEFINITION" href="26_glo_p.htm#place"><i>places</i></a> and
some manipulate <a rel="DEFINITION" href=
"26_glo_s.htm#setf_expander"><i>setf expanders</i></a>. A <a rel=
"DEFINITION" href="26_glo_s.htm#setf_expansion"><i>setf
expansion</i></a> can be derived from any <a rel="DEFINITION" href=
"26_glo_p.htm#place"><i>place</i></a>. New <a rel="DEFINITION"
href="26_glo_s.htm#setf_expander"><i>setf expanders</i></a> can be
defined by using <a rel="DEFINITION" href=
"m_defset.htm#defsetf"><b>defsetf</b></a> and <a rel="DEFINITION"
href=
"m_defi_3.htm#define-setf-expander"><b>define-setf-expander</b></a>.</p>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>5.1.1.1 Evaluation of Subforms to Places</h2>
<p>The following rules apply to the <a rel="DEFINITION" href=
"26_glo_e.htm#evaluation"><i>evaluation</i></a> of <a rel=
"DEFINITION" href="26_glo_s.htm#subform"><i>subforms</i></a> in a
<a rel="DEFINITION" href="26_glo_p.htm#place"><i>place</i></a>:</p>
<dl>
<dt>1. The evaluation ordering of <a rel="DEFINITION" href=
"26_glo_s.htm#subform"><i>subforms</i></a> within a <a rel=
"DEFINITION" href="26_glo_p.htm#place"><i>place</i></a> is
determined by the order specified by the second value returned by
<a rel="DEFINITION" href=
"f_get_se.htm#get-setf-expansion"><b>get-setf-expansion</b></a>.
For all <a rel="DEFINITION" href=
"26_glo_p.htm#place"><i>places</i></a> defined by this
specification (e.g., <a rel="DEFINITION" href=
"f_getf.htm#getf"><b>getf</b></a>, <a rel="DEFINITION" href=
"f_ldb.htm#ldb"><b>ldb</b></a>, ...), this order of evaluation is
left-to-right. When a <a rel="DEFINITION" href=
"26_glo_p.htm#place"><i>place</i></a> is derived from a macro
expansion, this rule is applied after the macro is expanded to find
the appropriate <a rel="DEFINITION" href=
"26_glo_p.htm#place"><i>place</i></a>.<br></dt>
<dd><a rel="DEFINITION" href="26_glo_p.htm#place"><i>Places</i></a>
defined by using <a rel="DEFINITION" href=
"m_defmac.htm#defmacro"><b>defmacro</b></a> or <a rel="DEFINITION"
href=
"m_defi_3.htm#define-setf-expander"><b>define-setf-expander</b></a>
use the evaluation order defined by those definitions. For example,
consider the following:
<pre>
 (defmacro wrong-order (x y) `(getf ,y ,x))
</pre>
<p>This following <a rel="DEFINITION" href=
"26_glo_f.htm#form"><i>form</i></a> evaluates <tt>place2</tt> first
and then <tt>place1</tt> because that is the order they are
evaluated in the macro expansion:</p>
<pre>
 (push value (wrong-order place1 place2))
</pre></dd>
<dt>2. For the <a rel="DEFINITION" href=
"26_glo_m.htm#macro"><i>macros</i></a> that manipulate <a rel=
"DEFINITION" href="26_glo_p.htm#place"><i>places</i></a> (<a rel=
"DEFINITION" href="m_push.htm#push"><b>push</b></a>, <a rel=
"DEFINITION" href="m_pshnew.htm#pushnew"><b>pushnew</b></a>,
<a rel="DEFINITION" href="m_remf.htm#remf"><b>remf</b></a>, <a rel=
"DEFINITION" href="m_incf_.htm#incf"><b>incf</b></a>, <a rel=
"DEFINITION" href="m_incf_.htm#decf"><b>decf</b></a>, <a rel=
"DEFINITION" href="m_shiftf.htm#shiftf"><b>shiftf</b></a>, <a rel=
"DEFINITION" href="m_rotate.htm#rotatef"><b>rotatef</b></a>,
<a rel="DEFINITION" href="m_setf_.htm#psetf"><b>psetf</b></a>,
<a rel="DEFINITION" href="m_setf_.htm#setf"><b>setf</b></a>,
<a rel="DEFINITION" href="m_pop.htm#pop"><b>pop</b></a>, and those
defined by <a rel="DEFINITION" href=
"m_defi_2.htm#define-modify-macro"><b>define-modify-macro</b></a>)
the <a rel="DEFINITION" href=
"26_glo_s.htm#subform"><i>subforms</i></a> of the macro call are
evaluated exactly once in left-to-right order, with the <a rel=
"DEFINITION" href="26_glo_s.htm#subform"><i>subforms</i></a> of the
<a rel="DEFINITION" href="26_glo_p.htm#place"><i>places</i></a>
evaluated in the order specified in (1).<br></dt>
<dd><a rel="DEFINITION" href="m_push.htm#push"><b>push</b></a>,
<a rel="DEFINITION" href="m_pshnew.htm#pushnew"><b>pushnew</b></a>,
<a rel="DEFINITION" href="m_remf.htm#remf"><b>remf</b></a>, <a rel=
"DEFINITION" href="m_incf_.htm#incf"><b>incf</b></a>, <a rel=
"DEFINITION" href="m_incf_.htm#decf"><b>decf</b></a>, <a rel=
"DEFINITION" href="m_shiftf.htm#shiftf"><b>shiftf</b></a>, <a rel=
"DEFINITION" href="m_rotate.htm#rotatef"><b>rotatef</b></a>,
<a rel="DEFINITION" href="m_setf_.htm#psetf"><b>psetf</b></a>,
<a rel="DEFINITION" href="m_pop.htm#pop"><b>pop</b></a> evaluate
all <a rel="DEFINITION" href=
"26_glo_s.htm#subform"><i>subforms</i></a> before modifying any of
the <a rel="DEFINITION" href="26_glo_p.htm#place"><i>place</i></a>
locations. <a rel="DEFINITION" href=
"m_setf_.htm#setf"><b>setf</b></a> (in the case when <a rel=
"DEFINITION" href="m_setf_.htm#setf"><b>setf</b></a> has more than
two arguments) performs its operation on each pair in sequence. For
example, in
<pre>
 (setf place1 value1 place2 value2 ...)
</pre>
the <a rel="DEFINITION" href=
"26_glo_s.htm#subform"><i>subforms</i></a> of <tt>place1</tt> and
<tt>value1</tt> are evaluated, the location specified by
<tt>place1</tt> is modified to contain the value returned by
<tt>value1</tt>, and then the rest of the <a rel="DEFINITION" href=
"m_setf_.htm#setf"><b>setf</b></a> form is processed in a like
manner.</dd>
<dt>3. For <a rel="DEFINITION" href=
"m_check_.htm#check-type"><b>check-type</b></a>, <a rel=
"DEFINITION" href="m_tpcase.htm#ctypecase"><b>ctypecase</b></a>,
and <a rel="DEFINITION" href="m_case_.htm#ccase"><b>ccase</b></a>,
<a rel="DEFINITION" href="26_glo_s.htm#subform"><i>subforms</i></a>
of the <a rel="DEFINITION" href=
"26_glo_p.htm#place"><i>place</i></a> are evaluated once as in (1),
but might be evaluated again if the type check fails in the case of
<a rel="DEFINITION" href=
"m_check_.htm#check-type"><b>check-type</b></a> or none of the
cases hold in <a rel="DEFINITION" href=
"m_tpcase.htm#ctypecase"><b>ctypecase</b></a> and <a rel=
"DEFINITION" href="m_case_.htm#ccase"><b>ccase</b></a>.<br></dt>
<dt>4. For <a rel="DEFINITION" href=
"m_assert.htm#assert"><b>assert</b></a>, the order of evaluation of
the generalized references is not specified.<br></dt>
</dl>
Rules 2, 3 and 4 cover all <a rel="DEFINITION" href=
"26_glo_s.htm#standardized"><i>standardized</i></a> <a rel=
"DEFINITION" href="26_glo_m.htm#macro"><i>macros</i></a> that
manipulate <a rel="DEFINITION" href=
"26_glo_p.htm#place"><i>places</i></a>. 
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>5.1.1.1.1 Examples of Evaluation of Subforms to Places</h2>
<pre>
 (let ((ref2 (list '())))
   (push (progn (princ "1") 'ref-1)
         (car (progn (princ "2") ref2)))) 
&gt;&gt;  12
=&gt;  (REF1)

 (let (x)
    (push (setq x (list 'a))
          (car (setq x (list 'b))))
     x)
=&gt;  (((A) . B))
</pre>
<p><a rel="DEFINITION" href="m_push.htm#push"><b>push</b></a> first
evaluates <tt>(setq x (list 'a)) =&gt; (a)</tt>, then evaluates
<tt>(setq x (list 'b)) =&gt; (b)</tt>, then modifies the <a rel=
"DEFINITION" href="26_glo_c.htm#car"><i>car</i></a> of this latest
value to be <tt>((a) . b)</tt>.</p>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>5.1.1.2 Setf Expansions</h2>
<p>Sometimes it is possible to avoid evaluating <a rel="DEFINITION"
href="26_glo_s.htm#subform"><i>subforms</i></a> of a <a rel=
"DEFINITION" href="26_glo_p.htm#place"><i>place</i></a> multiple
times or in the wrong order. A <a rel="DEFINITION" href=
"26_glo_s.htm#setf_expansion"><i>setf expansion</i></a> for a given
access form can be expressed as an ordered collection of five
<a rel="DEFINITION" href=
"26_glo_o.htm#object"><i>objects</i></a>:</p>
<dl>
<dt><b>List of temporary variables</b><br></dt>
<dd>a list of symbols naming temporary variables to be bound
sequentially, as if by <a rel="DEFINITION" href=
"s_let_l.htm#letST"><b>let*</b></a>, to <a rel="DEFINITION" href=
"26_glo_v.htm#value"><i>values</i></a> resulting from value
forms.</dd>
<dt><b>List of value forms</b><br></dt>
<dd>a list of forms (typically, <a rel="DEFINITION" href=
"26_glo_s.htm#subform"><i>subforms</i></a> of the <a rel=
"DEFINITION" href="26_glo_p.htm#place"><i>place</i></a>) which when
evaluated yield the values to which the corresponding temporary
variables should be bound.</dd>
<dt><b>List of store variables</b><br></dt>
<dd>a list of symbols naming temporary store variables which are to
hold the new values that will be assigned to the <a rel=
"DEFINITION" href="26_glo_p.htm#place"><i>place</i></a>.</dd>
<dt><b>Storing form</b><br></dt>
<dd>a form which can reference both the temporary and the store
variables, and which changes the <a rel="DEFINITION" href=
"26_glo_v.htm#value"><i>value</i></a> of the <a rel="DEFINITION"
href="26_glo_p.htm#place"><i>place</i></a> and guarantees to return
as its values the values of the store variables, which are the
correct values for <a rel="DEFINITION" href=
"m_setf_.htm#setf"><b>setf</b></a> to return.</dd>
<dt><b>Accessing form</b><br></dt>
<dd>a <a rel="DEFINITION" href="26_glo_f.htm#form"><i>form</i></a>
which can reference the temporary variables, and which returns the
<a rel="DEFINITION" href="26_glo_v.htm#value"><i>value</i></a> of
the <a rel="DEFINITION" href=
"26_glo_p.htm#place"><i>place</i></a>.</dd>
</dl>
<p>The value returned by the accessing form is affected by
execution of the storing form, but either of these forms might be
evaluated any number of times.</p>
<p>It is possible to do more than one <a rel="DEFINITION" href=
"m_setf_.htm#setf"><b>setf</b></a> in parallel via <a rel=
"DEFINITION" href="m_setf_.htm#psetf"><b>psetf</b></a>, <a rel=
"DEFINITION" href="m_shiftf.htm#shiftf"><b>shiftf</b></a>, and
<a rel="DEFINITION" href="m_rotate.htm#rotatef"><b>rotatef</b></a>.
Because of this, the <a rel="DEFINITION" href=
"26_glo_s.htm#setf_expander"><i>setf expander</i></a> must produce
new temporary and store variable names every time. For examples of
how to do this, see <a rel="DEFINITION" href=
"f_gensym.htm#gensym"><b>gensym</b></a>.</p>
<p>For each <a rel="DEFINITION" href=
"26_glo_s.htm#standardized"><i>standardized</i></a> accessor
function <i>F</i>, unless it is explicitly documented otherwise, it
is <a rel="DEFINITION" href=
"26_glo_i.htm#implementation-dependent"><i>implementation-dependent</i></a>
whether the ability to use an <i>F</i> <a rel="DEFINITION" href=
"26_glo_f.htm#form"><i>form</i></a> as a <a rel="DEFINITION" href=
"m_setf_.htm#setf"><b>setf</b></a> <a rel="DEFINITION" href=
"26_glo_p.htm#place"><i>place</i></a> is implemented by a <a rel=
"DEFINITION" href="26_glo_s.htm#setf_expander"><i>setf
expander</i></a> or a <a rel="DEFINITION" href=
"26_glo_s.htm#setf_function"><i>setf function</i></a>. Also, it
follows from this that it is <a rel="DEFINITION" href=
"26_glo_i.htm#implementation-dependent"><i>implementation-dependent</i></a>
whether the name <tt>(setf</tt> <i>F</i><tt>)</tt> is <a rel=
"DEFINITION" href="26_glo_f.htm#fbound"><i>fbound</i></a>.</p>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>5.1.1.2.1 Examples of Setf Expansions</h2>
<p>Examples of the contents of the constituents of <a rel=
"DEFINITION" href="26_glo_s.htm#setf_expansion"><i>setf
expansions</i></a> follow.</p>
<p>For a variable <i>x</i>:</p>
<pre>
()              ;list of temporary variables  
()              ;list of value forms          
(g0001)         ;list of store variables      
(setq x g0001)  ;storing form                 
x               ;accessing form               
</pre>
<p><b>Figure 5-3. Sample Setf Expansion of a Variable</b></p>
<p>For <tt>(car</tt> <i>exp</i><tt>)</tt>:</p>
<pre>
(g0002)                             ;list of temporary variables  
(exp)                               ;list of value forms          
(g0003)                             ;list of store variables      
(progn (rplaca g0002 g0003) g0003)  ;storing form                 
(car g0002)                         ;accessing form               
</pre>
<p><b>Figure 5-4. Sample Setf Expansion of a CAR Form</b></p>
<p>For <tt>(subseq</tt> <i>seq</i> <i>s</i> <i>e</i><tt>)</tt>:</p>
<pre>
(g0004 g0005 g0006)         ;list of temporary variables  
(seq s e)                   ;list of value forms          
(g0007)                     ;list of store variables      
(progn (replace g0004 g0007 :start1 g0005 :end1 g0006) g0007)                              
                            ;storing form                 
(subseq g0004 g0005 g0006)  ; accessing form              
</pre>
<p><b>Figure 5-5. Sample Setf Expansion of a SUBSEQ Form</b></p>
<p>In some cases, if a <a rel="DEFINITION" href=
"26_glo_s.htm#subform"><i>subform</i></a> of a <a rel="DEFINITION"
href="26_glo_p.htm#place"><i>place</i></a> is itself a <a rel=
"DEFINITION" href="26_glo_p.htm#place"><i>place</i></a>, it is
necessary to expand the <a rel="DEFINITION" href=
"26_glo_s.htm#subform"><i>subform</i></a> in order to compute some
of the values in the expansion of the outer <a rel="DEFINITION"
href="26_glo_p.htm#place"><i>place</i></a>. For <tt>(ldb</tt>
<i>bs</i> <tt>(car</tt> <i>exp</i><tt>))</tt>:</p>
<pre>
(g0001 g0002)            ;list of temporary variables  
(bs exp)                 ;list of value forms          
(g0003)                  ;list of store variables      
(progn (rplaca g0002 (dpb g0003 g0001 (car g0002))) g0003)                              
                         ;storing form                 
(ldb g0001 (car g0002))  ; accessing form              
</pre>
<p><b>Figure 5-6. Sample Setf Expansion of a LDB Form</b></p>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>5.1.2 Kinds of Places</h2>
<p>Several kinds of <a rel="DEFINITION" href=
"26_glo_p.htm#place"><i>places</i></a> are defined by Common Lisp;
this section enumerates them. This set can be extended by <a rel=
"DEFINITION" href=
"26_glo_i.htm#implementation"><i>implementations</i></a> and by
<a rel="DEFINITION" href=
"26_glo_p.htm#programmer_code"><i>programmer code</i></a>.</p>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>5.1.2.1 Variable Names as Places</h2>
<p>The name of a <a rel="DEFINITION" href=
"26_glo_l.htm#lexical_variable"><i>lexical variable</i></a> or
<a rel="DEFINITION" href="26_glo_d.htm#dynamic_variable"><i>dynamic
variable</i></a> can be used as a <a rel="DEFINITION" href=
"26_glo_p.htm#place"><i>place</i></a>.</p>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>5.1.2.2 Function Call Forms as Places</h2>
<p>A <a rel="DEFINITION" href=
"26_glo_f.htm#function_form"><i>function form</i></a> can be used
as a <a rel="DEFINITION" href="26_glo_p.htm#place"><i>place</i></a>
if it falls into one of the following categories:</p>
<dl>
<dt>* A function call form whose first element is the name of any
one of the functions in the next figure.<br></dt>
<dd>
<pre>
<a rel="DEFINITION" href="f_aref.htm#aref">aref</a>    <a rel=
"DEFINITION" href=
"f_car_c.htm#cdadr">cdadr</a>                    <a rel=
"DEFINITION" href=
"f_get.htm#get">get</a>                            
<a rel="DEFINITION" href="a_bit.htm#bit">bit</a>     <a rel=
"DEFINITION" href=
"f_car_c.htm#cdar">cdar</a>                     <a rel="DEFINITION"
href="f_gethas.htm#gethash">gethash</a>                        
<a rel="DEFINITION" href="f_car_c.htm#caaaar">caaaar</a>  <a rel=
"DEFINITION" href=
"f_car_c.htm#cddaar">cddaar</a>                   <a rel=
"DEFINITION" href=
"f_logica.htm#logical-pathname-translations">logical-pathname-translations</a>  
<a rel="DEFINITION" href="f_car_c.htm#caaadr">caaadr</a>  <a rel=
"DEFINITION" href=
"f_car_c.htm#cddadr">cddadr</a>                   <a rel=
"DEFINITION" href=
"f_macro_.htm#macro-function">macro-function</a>                 
<a rel="DEFINITION" href="f_car_c.htm#caaar">caaar</a>   <a rel=
"DEFINITION" href=
"f_car_c.htm#cddar">cddar</a>                    <a rel=
"DEFINITION" href=
"f_firstc.htm#ninth">ninth</a>                          
<a rel="DEFINITION" href="f_car_c.htm#caadar">caadar</a>  <a rel=
"DEFINITION" href=
"f_car_c.htm#cdddar">cdddar</a>                   <a rel=
"DEFINITION" href=
"f_nth.htm#nth">nth</a>                            
<a rel="DEFINITION" href="f_car_c.htm#caaddr">caaddr</a>  <a rel=
"DEFINITION" href=
"f_car_c.htm#cddddr">cddddr</a>                   <a rel=
"DEFINITION" href=
"f_rdtabl.htm#readtable-case">readtable-case</a>                 
<a rel="DEFINITION" href="f_car_c.htm#caadr">caadr</a>   <a rel=
"DEFINITION" href=
"f_car_c.htm#cdddr">cdddr</a>                    <a rel=
"DEFINITION" href=
"f_rest.htm#rest">rest</a>                           
<a rel="DEFINITION" href="f_car_c.htm#caar">caar</a>    <a rel=
"DEFINITION" href=
"f_car_c.htm#cddr">cddr</a>                     <a rel="DEFINITION"
href=
"f_row_ma.htm#row-major-aref">row-major-aref</a>                 
<a rel="DEFINITION" href="f_car_c.htm#cadaar">cadaar</a>  <a rel=
"DEFINITION" href=
"f_car_c.htm#cdr">cdr</a>                      <a rel="DEFINITION"
href="f_bt_sb.htm#sbit">sbit</a>                           
<a rel="DEFINITION" href="f_car_c.htm#cadadr">cadadr</a>  <a rel=
"DEFINITION" href=
"f_char_.htm#char">char</a>                     <a rel="DEFINITION"
href="f_char_.htm#schar">schar</a>                          
<a rel="DEFINITION" href="f_car_c.htm#cadar">cadar</a>   <a rel=
"DEFINITION" href=
"f_class_.htm#class-name">class-name</a>               <a rel=
"DEFINITION" href=
"f_firstc.htm#second">second</a>                         
<a rel="DEFINITION" href="f_car_c.htm#caddar">caddar</a>  <a rel=
"DEFINITION" href=
"f_cmp_ma.htm#compiler-macro-function">compiler-macro-function</a>  <a rel="DEFINITION"
href="f_firstc.htm#seventh">seventh</a>                        
<a rel="DEFINITION" href="f_car_c.htm#cadddr">cadddr</a>  <a rel=
"DEFINITION" href=
"f_docume.htm#documentation">documentation</a>            <a rel=
"DEFINITION" href=
"f_firstc.htm#sixth">sixth</a>                          
<a rel="DEFINITION" href="f_car_c.htm#caddr">caddr</a>   <a rel=
"DEFINITION" href=
"f_firstc.htm#eighth">eighth</a>                   <a rel=
"DEFINITION" href=
"f_slt_va.htm#slot-value">slot-value</a>                     
<a rel="DEFINITION" href="f_car_c.htm#cadr">cadr</a>    <a rel=
"DEFINITION" href=
"f_elt.htm#elt">elt</a>                      <a rel="DEFINITION"
href="f_subseq.htm#subseq">subseq</a>                         
<a rel="DEFINITION" href="f_car_c.htm#car">car</a>     <a rel=
"DEFINITION" href=
"f_fdefin.htm#fdefinition">fdefinition</a>              <a rel=
"DEFINITION" href=
"f_svref.htm#svref">svref</a>                          
<a rel="DEFINITION" href="f_car_c.htm#cdaaar">cdaaar</a>  <a rel=
"DEFINITION" href=
"f_firstc.htm#fifth">fifth</a>                    <a rel=
"DEFINITION" href=
"f_symb_1.htm#symbol-function">symbol-function</a>                
<a rel="DEFINITION" href="f_car_c.htm#cdaadr">cdaadr</a>  <a rel=
"DEFINITION" href=
"f_fill_p.htm#fill-pointer">fill-pointer</a>             <a rel=
"DEFINITION" href=
"f_symb_4.htm#symbol-plist">symbol-plist</a>                   
<a rel="DEFINITION" href="f_car_c.htm#cdaar">cdaar</a>   <a rel=
"DEFINITION" href=
"f_find_c.htm#find-class">find-class</a>               <a rel=
"DEFINITION" href=
"f_symb_5.htm#symbol-value">symbol-value</a>                   
<a rel="DEFINITION" href="f_car_c.htm#cdadar">cdadar</a>  <a rel=
"DEFINITION" href=
"f_firstc.htm#first">first</a>                    <a rel=
"DEFINITION" href=
"f_firstc.htm#tenth">tenth</a>                          
<a rel="DEFINITION" href="f_car_c.htm#cdaddr">cdaddr</a>  <a rel=
"DEFINITION" href=
"f_firstc.htm#fourth">fourth</a>                   <a rel=
"DEFINITION" href=
"f_firstc.htm#third">third</a>                          
</pre>
<p><b>Figure 5-7. Functions that setf can be used with---1</b></p>
<p>In the case of <a rel="DEFINITION" href=
"f_subseq.htm#subseq"><b>subseq</b></a>, the replacement value must
be a <a rel="DEFINITION" href=
"26_glo_s.htm#sequence"><i>sequence</i></a> whose elements might be
contained by the sequence argument to <a rel="DEFINITION" href=
"f_subseq.htm#subseq"><b>subseq</b></a>, but does not have to be a
<a rel="DEFINITION" href=
"26_glo_s.htm#sequence"><i>sequence</i></a> of the same <a rel=
"DEFINITION" href="26_glo_t.htm#type"><i>type</i></a> as the
<a rel="DEFINITION" href=
"26_glo_s.htm#sequence"><i>sequence</i></a> of which the
subsequence is specified. If the length of the replacement value
does not equal the length of the subsequence to be replaced, then
the shorter length determines the number of elements to be stored,
as for <a rel="DEFINITION" href=
"f_replac.htm#replace"><b>replace</b></a>.</p>
</dd>
<dt>* A function call form whose first element is the name of a
selector function constructed by <a rel="DEFINITION" href=
"m_defstr.htm#defstruct"><b>defstruct</b></a>. The function name
must refer to the global function definition, rather than a locally
defined <a rel="DEFINITION" href=
"26_glo_f.htm#function"><i>function</i></a>.<br></dt>
<dt>* A function call form whose first element is the name of any
one of the functions in the next figure, provided that the supplied
argument to that function is in turn a <a rel="DEFINITION" href=
"26_glo_p.htm#place"><i>place</i></a> form; in this case the new
<a rel="DEFINITION" href="26_glo_p.htm#place"><i>place</i></a> has
stored back into it the result of applying the supplied "update"
function.<br></dt>
<dd>
<pre>
Function name  Argument that is a place  Update function used      
<a rel="DEFINITION" href=
"f_ldb.htm#ldb">ldb</a>            second                    <a rel="DEFINITION"
href="f_dpb.htm#dpb">dpb</a>                       
<a rel="DEFINITION" href=
"f_mask_f.htm#mask-field">mask-field</a>     second                    <a rel="DEFINITION"
href="f_deposi.htm#deposit-field">deposit-field</a>             
<a rel="DEFINITION" href=
"f_getf.htm#getf">getf</a>           first                     <a rel="DEFINITION"
href=
"26_glo_i.htm#implementation-dependent">implementation-dependent</a>  
</pre>
<p><b>Figure 5-8. Functions that setf can be used with---2</b>
During the <a rel="DEFINITION" href=
"m_setf_.htm#setf"><b>setf</b></a> expansion of these <a rel=
"DEFINITION" href="26_glo_f.htm#form"><i>forms</i></a>, it is
necessary to call <a rel="DEFINITION" href=
"f_get_se.htm#get-setf-expansion"><b>get-setf-expansion</b></a> in
order to figure out how the inner, nested generalized variable must
be treated.</p>
<p>The information from <a rel="DEFINITION" href=
"f_get_se.htm#get-setf-expansion"><b>get-setf-expansion</b></a> is
used as follows.</p>
<dl>
<dt><a rel="DEFINITION" href=
"f_ldb.htm#ldb"><b>ldb</b></a><br></dt>
<dd>In a form such as:
<p><tt>(setf (ldb</tt> <i>byte-spec</i> <i>place-form</i><tt>)</tt>
<i>value-form</i><tt>)</tt></p>
<p>the place referred to by the <i>place-form</i> must always be
both <a rel="DEFINITION" href="26_glo_r.htm#read"><i>read</i></a>
and <i>written</i>; note that the update is to the generalized
variable specified by <i>place-form</i>, not to any object of
<a rel="DEFINITION" href="26_glo_t.htm#type"><i>type</i></a>
<a rel="DEFINITION" href=
"t_intege.htm#integer"><b>integer</b></a>.</p>
<p>Thus this <a rel="DEFINITION" href=
"m_setf_.htm#setf"><b>setf</b></a> should generate code to do the
following:</p>
<dl>
<dt>1. Evaluate <i>byte-spec</i> (and bind it into a temporary
variable).</dt>
<dt>2. Bind the temporary variables for <i>place-form</i>.</dt>
<dt>3. Evaluate <i>value-form</i> (and bind its value or values
into the store variable).</dt>
<dt>4. Do the <a rel="DEFINITION" href=
"26_glo_r.htm#read"><i>read</i></a> from <i>place-form</i>.</dt>
<dt>5. Do the <a rel="DEFINITION" href=
"26_glo_w.htm#write"><i>write</i></a> into <i>place-form</i> with
the given bits of the <a rel="DEFINITION" href=
"26_glo_i.htm#integer"><i>integer</i></a> fetched in step 4
replaced with the value from step 3.<br></dt>
</dl>
If the evaluation of <i>value-form</i> in step 3 alters what is
found in <i>place-form</i>, such as setting different bits of
<a rel="DEFINITION" href="26_glo_i.htm#integer"><i>integer</i></a>,
then the change of the bits denoted by <i>byte-spec</i> is to that
altered <a rel="DEFINITION" href=
"26_glo_i.htm#integer"><i>integer</i></a>, because step 4 is done
after the <i>value-form</i> evaluation. Nevertheless, the
evaluations required for <a rel="DEFINITION" href=
"26_glo_b.htm#binding"><i>binding</i></a> the temporary variables
are done in steps 1 and 2, and thus the expected left-to-right
evaluation order is seen. For example:
<pre>
 (setq integer #x69) =&gt;  #x69
 (rotatef (ldb (byte 4 4) integer) 
          (ldb (byte 4 0) integer))
 integer =&gt;  #x96
;;; This example is trying to swap two independent bit fields 
;;; in an integer.  Note that the generalized variable of 
;;; interest here is just the (possibly local) program variable
;;; integer.
</pre></dd>
<dt><a rel="DEFINITION" href=
"f_mask_f.htm#mask-field"><b>mask-field</b></a><br></dt>
<dd>This case is the same as <a rel="DEFINITION" href=
"f_ldb.htm#ldb"><b>ldb</b></a> in all essential aspects.</dd>
<dt><a rel="DEFINITION" href=
"f_getf.htm#getf"><b>getf</b></a><br></dt>
<dd>In a form such as:
<p><tt>(setf (getf</tt> <i>place-form</i> <i>ind-form</i><tt>)</tt>
<i>value-form</i><tt>)</tt></p>
<p>the place referred to by <i>place-form</i> must always be both
<a rel="DEFINITION" href="26_glo_r.htm#read"><i>read</i></a> and
<i>written</i>; note that the update is to the generalized variable
specified by <i>place-form</i>, not necessarily to the particular
<a rel="DEFINITION" href="26_glo_l.htm#list"><i>list</i></a> that
is the property list in question.</p>
<p>Thus this <a rel="DEFINITION" href=
"m_setf_.htm#setf"><b>setf</b></a> should generate code to do the
following:</p>
<dl>
<dt>1. Bind the temporary variables for <i>place-form</i>.</dt>
<dt>2. Evaluate <i>ind-form</i> (and bind it into a temporary
variable).</dt>
<dt>3. Evaluate <i>value-form</i> (and bind its value or values
into the store variable).</dt>
<dt>4. Do the <a rel="DEFINITION" href=
"26_glo_r.htm#read"><i>read</i></a> from <i>place-form</i>.</dt>
<dt>5. Do the <a rel="DEFINITION" href=
"26_glo_w.htm#write"><i>write</i></a> into <i>place-form</i> with a
possibly-new property list obtained by combining the values from
steps 2, 3, and 4. (Note that the phrase "possibly-new property
list" can mean that the former property list is somehow
destructively re-used, or it can mean partial or full copying of
it. Since either copying or destructive re-use can occur, the
treatment of the resultant value for the possibly-new property list
must proceed as if it were a different copy needing to be stored
back into the generalized variable.)<br></dt>
</dl>
If the evaluation of <i>value-form</i> in step 3 alters what is
found in <i>place-form</i>, such as setting a different named
property in the list, then the change of the property denoted by
<i>ind-form</i> is to that altered list, because step 4 is done
after the <i>value-form</i> evaluation. Nevertheless, the
evaluations required for <a rel="DEFINITION" href=
"26_glo_b.htm#binding"><i>binding</i></a> the temporary variables
are done in steps 1 and 2, and thus the expected left-to-right
evaluation order is seen.
<p>For example:</p>
<pre>
 (setq s (setq r (list (list 'a 1 'b 2 'c 3)))) =&gt;  ((a 1 b 2 c 3))
 (setf (getf (car r) 'b) 
       (progn (setq r nil) 6)) =&gt;  6
 r =&gt;  NIL
 s =&gt;  ((A 1 B 6 C 3))
;;; Note that the (setq r nil) does not affect the actions of 
;;; the SETF because the value of R had already been saved in 
;;; a temporary variable as part of the step 1. Only the CAR
;;; of this value will be retrieved, and subsequently modified 
;;; after the value computation.
</pre></dd>
</dl>
</dd>
</dl>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>5.1.2.3 VALUES Forms as Places</h2>
<p>A <a rel="DEFINITION" href=
"f_values.htm#values"><b>values</b></a> <a rel="DEFINITION" href=
"26_glo_f.htm#form"><i>form</i></a> can be used as a <a rel=
"DEFINITION" href="26_glo_p.htm#place"><i>place</i></a>, provided
that each of its <a rel="DEFINITION" href=
"26_glo_s.htm#subform"><i>subforms</i></a> is also a <a rel=
"DEFINITION" href="26_glo_p.htm#place"><i>place</i></a> form.</p>
<p>A form such as</p>
<p><tt>(setf (values</tt> <i>place-1</i>
<tt>...</tt><i>place-n</i><tt>)</tt>
<i>values-form</i><tt>)</tt></p>
<p>does the following:</p>
<dl>
<dt>1. The <a rel="DEFINITION" href=
"26_glo_s.htm#subform"><i>subforms</i></a> of each nested
<i>place</i> are evaluated in left-to-right order.</dt>
<dt>2. The <i>values-form</i> is evaluated, and the first store
variable from each <i>place</i> is bound to its return values as if
by <a rel="DEFINITION" href=
"m_multip.htm#multiple-value-bind"><b>multiple-value-bind</b></a>.</dt>
<dt>3. If the <a rel="DEFINITION" href=
"26_glo_s.htm#setf_expansion"><i>setf expansion</i></a> for any
<i>place</i> involves more than one store variable, then the
additional store variables are bound to <a rel="DEFINITION" href=
"a_nil.htm#nil"><b>nil</b></a>.</dt>
<dt>4. The storing forms for each <i>place</i> are evaluated in
left-to-right order.<br></dt>
</dl>
<p>The storing form in the <a rel="DEFINITION" href=
"26_glo_s.htm#setf_expansion"><i>setf expansion</i></a> of <a rel=
"DEFINITION" href="f_values.htm#values"><b>values</b></a> returns
as <a rel="DEFINITION" href=
"26_glo_m.htm#multiple_values"><i>multiple values</i></a>[2] the
values of the store variables in step 2. That is, the number of
values returned is the same as the number of <a rel="DEFINITION"
href="26_glo_p.htm#place"><i>place</i></a> forms. This may be more
or fewer values than are produced by the <i>values-form</i>.</p>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>5.1.2.4 THE Forms as Places</h2>
<p>A <a rel="DEFINITION" href="s_the.htm#the"><b>the</b></a>
<a rel="DEFINITION" href="26_glo_f.htm#form"><i>form</i></a> can be
used as a <a rel="DEFINITION" href=
"26_glo_p.htm#place"><i>place</i></a>, in which case the
declaration is transferred to the <i>newvalue</i> form, and the
resulting <a rel="DEFINITION" href=
"m_setf_.htm#setf"><b>setf</b></a> is analyzed. For example,</p>
<pre>
 (setf (the integer (cadr x)) (+ y 3))
</pre>
is processed as if it were
<pre>
 (setf (cadr x) (the integer (+ y 3)))
</pre>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>5.1.2.5 APPLY Forms as Places</h2>
<p>The following situations involving <a rel="DEFINITION" href=
"m_setf_.htm#setf"><b>setf</b></a> of <a rel="DEFINITION" href=
"f_apply.htm#apply"><b>apply</b></a> must be supported:</p>
<dl>
<dt>* <tt>(setf (apply #'aref</tt> <i>array</i>
<i>subscript</i><b>*</b> <i>more-subscripts</i><tt>)</tt>
<i>new-element</i><tt>)</tt></dt>
<dt>* <tt>(setf (apply #'bit</tt> <i>array</i>
<i>subscript</i><b>*</b> <i>more-subscripts</i><tt>)</tt>
<i>new-element</i><tt>)</tt></dt>
<dt>* <tt>(setf (apply #'sbit</tt> <i>array</i>
<i>subscript</i><b>*</b> <i>more-subscripts</i><tt>)</tt>
<i>new-element</i><tt>)</tt><br></dt>
</dl>
<p>In all three cases, the <a rel="DEFINITION" href=
"26_glo_e.htm#element"><i>element</i></a> of <i>array</i>
designated by the concatenation of <i>subscripts</i> and
<i>more-subscripts</i> (i.e., the same <a rel="DEFINITION" href=
"26_glo_e.htm#element"><i>element</i></a> which would be <a rel=
"DEFINITION" href="26_glo_r.htm#read"><i>read</i></a> by the call
to <a rel="DEFINITION" href="26_glo_a.htm#apply"><i>apply</i></a>
if it were not part of a <a rel="DEFINITION" href=
"m_setf_.htm#setf"><b>setf</b></a> <a rel="DEFINITION" href=
"26_glo_f.htm#form"><i>form</i></a>) is changed to have the <a rel=
"DEFINITION" href="26_glo_v.htm#value"><i>value</i></a> given by
<i>new-element</i>. For these usages, the function name (<a rel=
"DEFINITION" href="f_aref.htm#aref"><b>aref</b></a>, <a rel=
"DEFINITION" href="f_bt_sb.htm#bit"><b>bit</b></a>, or <a rel=
"DEFINITION" href="f_bt_sb.htm#sbit"><b>sbit</b></a>) must refer to
the global function definition, rather than a locally defined
<a rel="DEFINITION" href=
"26_glo_f.htm#function"><i>function</i></a>.</p>
<p>No other <a rel="DEFINITION" href=
"26_glo_s.htm#standardized"><i>standardized</i></a> <a rel=
"DEFINITION" href="26_glo_f.htm#function"><i>function</i></a> is
required to be supported, but an <a rel="DEFINITION" href=
"26_glo_i.htm#implementation"><i>implementation</i></a> may define
such support. An <a rel="DEFINITION" href=
"26_glo_i.htm#implementation"><i>implementation</i></a> may also
define support for <a rel="DEFINITION" href=
"26_glo_i.htm#implementation-defined"><i>implementation-defined</i></a>
<a rel="DEFINITION" href=
"26_glo_o.htm#operator"><i>operators</i></a>.</p>
<p>If a user-defined <a rel="DEFINITION" href=
"26_glo_f.htm#function"><i>function</i></a> is used in this
context, the following equivalence is true, except that care is
taken to preserve proper left-to-right evaluation of argument
<a rel="DEFINITION" href=
"26_glo_s.htm#subform"><i>subforms</i></a>:</p>
<pre>
 (setf (apply #'name arg*) val)
 ==  (apply #'(setf name) val arg*)
</pre>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>5.1.2.6 Setf Expansions and Places</h2>
<p>Any <a rel="DEFINITION" href=
"26_glo_c.htm#compound_form"><i>compound form</i></a> for which the
<a rel="DEFINITION" href=
"26_glo_o.htm#operator"><i>operator</i></a> has a <a rel=
"DEFINITION" href="26_glo_s.htm#setf_expander"><i>setf
expander</i></a> defined can be used as a <a rel="DEFINITION" href=
"26_glo_p.htm#place"><i>place</i></a>. The <a rel="DEFINITION"
href="26_glo_o.htm#operator"><i>operator</i></a> must refer to the
global function definition, rather than a locally defined <a rel=
"DEFINITION" href="26_glo_f.htm#function"><i>function</i></a> or
<a rel="DEFINITION" href="26_glo_m.htm#macro"><i>macro</i></a>.</p>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>5.1.2.7 Macro Forms as Places</h2>
<p>A <a rel="DEFINITION" href="26_glo_m.htm#macro_form"><i>macro
form</i></a> can be used as a <a rel="DEFINITION" href=
"26_glo_p.htm#place"><i>place</i></a>, in which case Common Lisp
expands the <a rel="DEFINITION" href=
"26_glo_m.htm#macro_form"><i>macro form</i></a> as if by <a rel=
"DEFINITION" href=
"f_mexp_.htm#macroexpand-1"><b>macroexpand-1</b></a> and then uses
the <a rel="DEFINITION" href=
"26_glo_m.htm#macro_expansion"><i>macro expansion</i></a> in place
of the original <a rel="DEFINITION" href=
"26_glo_p.htm#place"><i>place</i></a>. Such <a rel="DEFINITION"
href="26_glo_m.htm#macro_expansion"><i>macro expansion</i></a> is
attempted only after exhausting all other possibilities other than
expanding into a call to a function named <tt>(setf</tt>
<i>reader</i><tt>)</tt>.</p>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>5.1.2.8 Symbol Macros as Places</h2>
<p>A reference to a <a rel="DEFINITION" href=
"26_glo_s.htm#symbol"><i>symbol</i></a> that has been
<i>established</i> as a <a rel="DEFINITION" href=
"26_glo_s.htm#symbol_macro"><i>symbol macro</i></a> can be used as
a <a rel="DEFINITION" href="26_glo_p.htm#place"><i>place</i></a>.
In this case, <a rel="DEFINITION" href=
"m_setf_.htm#setf"><b>setf</b></a> expands the reference and then
analyzes the resulting <a rel="DEFINITION" href=
"26_glo_f.htm#form"><i>form</i></a>.</p>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>5.1.2.9 Other Compound Forms as Places</h2>
<p>For any other <a rel="DEFINITION" href=
"26_glo_c.htm#compound_form"><i>compound form</i></a> for which the
<a rel="DEFINITION" href=
"26_glo_o.htm#operator"><i>operator</i></a> is a <a rel=
"DEFINITION" href="26_glo_s.htm#symbol"><i>symbol</i></a> <i>f</i>,
the <a rel="DEFINITION" href="m_setf_.htm#setf"><b>setf</b></a>
<a rel="DEFINITION" href="26_glo_f.htm#form"><i>form</i></a>
expands into a call to the <a rel="DEFINITION" href=
"26_glo_f.htm#function"><i>function</i></a> named <tt>(setf</tt>
<i>f</i><tt>)</tt>. The first <a rel="DEFINITION" href=
"26_glo_a.htm#argument"><i>argument</i></a> in the newly
constructed <a rel="DEFINITION" href=
"26_glo_f.htm#function_form"><i>function form</i></a> is
<i>newvalue</i> and the remaining <a rel="DEFINITION" href=
"26_glo_a.htm#argument"><i>arguments</i></a> are the remaining
<a rel="DEFINITION" href="26_glo_e.htm#element"><i>elements</i></a>
of <i>place</i>. This expansion occurs regardless of whether
<i>f</i> or <tt>(setf</tt> <i>f</i><tt>)</tt> is defined as a
<a rel="DEFINITION" href=
"26_glo_f.htm#function"><i>function</i></a> locally, globally, or
not at all. For example,</p>
<p><tt>(setf (</tt><i>f</i> <i>arg1</i> <i>arg2</i> <tt>...)</tt>
<i>new-value</i><tt>)</tt></p>
<p>expands into a form with the same effect and value as</p>
<pre>
 (let ((#:temp-1 arg1)          ;force correct order of evaluation
       (#:temp-2 arg2)
       ...
       (#:temp-0 new-value))
   (funcall (function (setf f)) #:temp-0 #:temp-1 #:temp-2...))
</pre>
<p>A <a rel="DEFINITION" href=
"26_glo_f.htm#function"><i>function</i></a> named <tt>(setf</tt>
<i>f</i><tt>)</tt> must return its first argument as its only value
in order to preserve the semantics of <a rel="DEFINITION" href=
"m_setf_.htm#setf"><b>setf</b></a>.</p>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>5.1.3 Treatment of Other Macros Based on SETF</h2>
<p>For each of the "read-modify-write" <a rel="DEFINITION" href=
"26_glo_o.htm#operator"><i>operators</i></a> in the next figure,
and for any additional <a rel="DEFINITION" href=
"26_glo_m.htm#macro"><i>macros</i></a> defined by the <a rel=
"DEFINITION" href="26_glo_p.htm#programmer"><i>programmer</i></a>
using <a rel="DEFINITION" href=
"m_defi_2.htm#define-modify-macro"><b>define-modify-macro</b></a>,
an exception is made to the normal rule of left-to-right evaluation
of arguments. Evaluation of <a rel="DEFINITION" href=
"26_glo_a.htm#argument"><i>argument</i></a> <a rel="DEFINITION"
href="26_glo_f.htm#form"><i>forms</i></a> occurs in left-to-right
order, with the exception that for the <i>place</i> <a rel=
"DEFINITION" href="26_glo_a.htm#argument"><i>argument</i></a>, the
actual <a rel="DEFINITION" href="26_glo_r.htm#read"><i>read</i></a>
of the "old value" from that <i>place</i> happens after all of the
<a rel="DEFINITION" href=
"26_glo_a.htm#argument"><i>argument</i></a> <a rel="DEFINITION"
href="26_glo_f.htm#form"><i>form</i></a> <a rel="DEFINITION" href=
"26_glo_e.htm#evaluation"><i>evaluations</i></a>, and just before a
"new value" is computed and <i>written</i> back into the
<i>place</i>.</p>
<p>Specifically, each of these <a rel="DEFINITION" href=
"26_glo_o.htm#operator"><i>operators</i></a> can be viewed as
involving a <a rel="DEFINITION" href=
"26_glo_f.htm#form"><i>form</i></a> with the following general
syntax:</p>
<pre>
 (<a rel="DEFINITION" href=
"26_glo_o.htm#operator">operator</a> preceding-form* place following-form*)
</pre>
<p>The evaluation of each such <a rel="DEFINITION" href=
"26_glo_f.htm#form"><i>form</i></a> proceeds like this:</p>
<dl>
<dt>1. <a rel="DEFINITION" href=
"26_glo_e.htm#evaluate"><i>Evaluate</i></a> each of the
<i>preceding-forms</i>, in left-to-right order.</dt>
<dt>2. <a rel="DEFINITION" href=
"26_glo_e.htm#evaluate"><i>Evaluate</i></a> the <a rel="DEFINITION"
href="26_glo_s.htm#subform"><i>subforms</i></a> of the
<i>place</i>, in the order specified by the second value of the
<a rel="DEFINITION" href="26_glo_s.htm#setf_expansion"><i>setf
expansion</i></a> for that <i>place</i>.</dt>
<dt>3. <a rel="DEFINITION" href=
"26_glo_e.htm#evaluate"><i>Evaluate</i></a> each of the
<i>following-forms</i>, in left-to-right order.</dt>
<dt>4. <a rel="DEFINITION" href="26_glo_r.htm#read"><i>Read</i></a>
the old value from <i>place</i>.</dt>
<dt>5. Compute the new value.</dt>
<dt>6. Store the new value into <i>place</i>.<br></dt>
</dl>
<pre>
<a rel="DEFINITION" href="m_incf_.htm#decf">decf</a>  <a rel=
"DEFINITION" href="m_pop.htm#pop">pop</a>   <a rel="DEFINITION"
href="m_pshnew.htm#pushnew">pushnew</a>  
<a rel="DEFINITION" href="m_incf_.htm#incf">incf</a>  <a rel=
"DEFINITION" href="m_push.htm#push">push</a>  <a rel="DEFINITION"
href="m_remf.htm#remf">remf</a>     
</pre>
<p><b>Figure 5-9. Read-Modify-Write Macros</b></p>
<!-- Common Lisp HyperSpec (TM), version 7.0 generated by Kent M. Pitman on Mon, 11-Apr-2005 2:31am EDT -->
<h2>5.2 Transfer of Control to an Exit Point</h2>
<p>When a transfer of control is initiated by <a rel="DEFINITION"
href="s_go.htm#go"><b>go</b></a>, <a rel="DEFINITION" href=
"s_ret_fr.htm#return-from"><b>return-from</b></a>, or <a rel=
"DEFINITION" href="s_throw.htm#throw"><b>throw</b></a> the
following events occur in order to accomplish the transfer of
control. Note that for <a rel="DEFINITION" href=
"s_go.htm#go"><b>go</b></a>, the <a rel="DEFINITION" href=
"26_glo_e.htm#exit_point"><i>exit point</i></a> is the <a rel=
"DEFINITION" href="26_glo_f.htm#form"><i>form</i></a> within the
<a rel="DEFINITION" href="s_tagbod.htm#tagbody"><b>tagbody</b></a>
that is being executed at the time the <a rel="DEFINITION" href=
"s_go.htm#go"><b>go</b></a> is performed; for <a rel="DEFINITION"
href="s_ret_fr.htm#return-from"><b>return-from</b></a>, the <a rel=
"DEFINITION" href="26_glo_e.htm#exit_point"><i>exit point</i></a>
is the corresponding <a rel="DEFINITION" href=
"s_block.htm#block"><b>block</b></a> <a rel="DEFINITION" href=
"26_glo_f.htm#form"><i>form</i></a>; and for <a rel="DEFINITION"
href="s_throw.htm#throw"><b>throw</b></a>, the <a rel="DEFINITION"
href="26_glo_e.htm#exit_point"><i>exit point</i></a> is the
corresponding <a rel="DEFINITION" href=
"s_catch.htm#catch"><b>catch</b></a> <a rel="DEFINITION" href=
"26_glo_f.htm#form"><i>form</i></a>.</p>
<dl>
<dt>1. Intervening <a rel="DEFINITION" href=
"26_glo_e.htm#exit_point"><i>exit points</i></a> are "abandoned"
(i.e., their <a rel="DEFINITION" href=
"26_glo_e.htm#extent"><i>extent</i></a> ends and it is no longer
valid to attempt to transfer control through them).<br></dt>
<dt>2. The cleanup clauses of any intervening <a rel="DEFINITION"
href="s_unwind.htm#unwind-protect"><b>unwind-protect</b></a>
clauses are evaluated.<br></dt>
<dt>3. Intervening dynamic <a rel="DEFINITION" href=
"26_glo_b.htm#binding"><i>bindings</i></a> of <a rel="DEFINITION"
href="d_specia.htm#special"><b>special</b></a> variables, <a rel=
"DEFINITION" href="26_glo_c.htm#catch_tag"><i>catch tags</i></a>,
<a rel="DEFINITION" href=
"26_glo_c.htm#condition_handler"><i>condition handlers</i></a>, and
<a rel="DEFINITION" href="26_glo_r.htm#restart"><i>restarts</i></a>
are undone.<br></dt>
<dt>4. The <a rel="DEFINITION" href=
"26_glo_e.htm#extent"><i>extent</i></a> of the <a rel="DEFINITION"
href="26_glo_e.htm#exit_point"><i>exit point</i></a> being invoked
ends, and control is passed to the target.<br></dt>
</dl>
<p>The extent of an exit being "abandoned" because it is being
passed over ends as soon as the transfer of control is initiated.
That is, event 1 occurs at the beginning of the initiation of the
transfer of control. The consequences are undefined if an attempt
is made to transfer control to an <a rel="DEFINITION" href=
"26_glo_e.htm#exit_point"><i>exit point</i></a> whose <a rel=
"DEFINITION" href="26_glo_d.htm#dynamic_extent"><i>dynamic
extent</i></a> has ended.</p>
<p>Events 2 and 3 are actually performed interleaved, in the order
corresponding to the reverse order in which they were established.
The effect of this is that the cleanup clauses of an <a rel=
"DEFINITION" href=
"s_unwind.htm#unwind-protect"><b>unwind-protect</b></a> see the
same dynamic <a rel="DEFINITION" href=
"26_glo_b.htm#binding"><i>bindings</i></a> of variables and <a rel=
"DEFINITION" href="26_glo_c.htm#catch_tag"><i>catch tags</i></a> as
were visible when the <a rel="DEFINITION" href=
"s_unwind.htm#unwind-protect"><b>unwind-protect</b></a> was
entered.</p>
<p>Event 4 occurs at the end of the transfer of control.</p>
</body>
</html>
