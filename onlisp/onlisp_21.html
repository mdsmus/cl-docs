<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML lang="ja">
<!-- Created on February, 11  2006 by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=euc-jp">
<META NAME="keywords" CONTENT="meadow,mule,emacs,lisp,elisp,gnus,setting,unix,cygwin">
<META http-equiv="Content-Script-Type" content="text/javascript">
<META NAME="description" CONTENT="On Lisp Html version">
<TITLE>Onlisp:  Continuations</TITLE>

<META NAME="description" CONTENT="Onlisp:  Continuations">
<META NAME="keywords" CONTENT="Onlisp:  Continuations">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">

<LINK REL="contents" HREF="onlisp_toc.html#SEC_Contents">
<LINK REL="index" HREF="onlisp_31.html#SEC168">
<LINK REL="next" HREF="onlisp_22.html#SEC130">
<LINK REL="prev" HREF="onlisp_20.html#SEC120">

<META http-equiv="Content-Style-Type" content="text/css">
<link rel="StyleSheet" href="css/midnight.css" type="text/css" id="css1">
<script type="text/javascript" src="style1.js"></script>
<link rel="stylesheet" type="text/css" href="css/meadowmemo.css">

</HEAD>
<BODY LANG="ja" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">
<!--Infoseek Analyzer start-->
<script LANGUAGE="javascript">PgNo=20;</script>
<script src="http://js1.infoseek.co.jp/bin/57/00170.js"></script>
<noscript><a href="http://ax1.www.infoseek.co.jp/bin/go?0017057t" target="_blank">
<img src="http://ax1.www.infoseek.co.jp/bin/logo?0017057t" border=0></a></noscript>
<!--Infoseek Analyzer end-->
<a name="top"> </a>

<br><A NAME="SEC126"> </A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_20.html#SEC125"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_21.html#SEC127"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_20.html#SEC120"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_22.html#SEC130"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_31.html#SEC168">Index</A>]</TD>
<TD> [<a href="#top">Page Top</a> / <a href="#bottom">Bottom</a>]</TD></TR></TABLE>
<A NAME="Continuations"></A>
<H1> 20. Continuations </H1>
<!--docid::SEC126::-->
<div class="info">URL="<a href="http://www.bookshelf.jp/cgi-bin/goto.cgi?file=onlisp&node=Continuations">http://www.bookshelf.jp/cgi-bin/goto.cgi?file=onlisp&node=Continuations</a>"<br>
<a href="http://www.bookshelf.jp/pukiwiki/pukiwiki.php?refer=MeadowMemo&cmd=read&page=onlisp%2FContinuations">comment</a>(none) to "onlisp/Continuations"</div><FORM METHOD="GET" ACTION="http://www.bookshelf.jp/cgi-bin/wwwsrch.cgi"><div class="info">search<INPUT TYPE=text NAME=WORD SIZE=30><INPUT TYPE=hidden NAME=dir VALUE=texi/onlisp><INPUT TYPE=hidden NAME=index VALUE=dirsearch CHECKED><INPUT TYPE=hidden NAME=langmode VALUE=en><INPUT TYPE=hidden NAME=target VALUE=all CHECKED><INPUT TYPE=hidden NAME=ANDOR VALUE=and CHECKED><INPUT TYPE=radio NAME=lisp VALUE=off CHECKED>Search<INPUT TYPE=radio NAME=lisp VALUE=on>Elisp<INPUT TYPE=submit VALUE="Search"></div></FORM>
<P>

A continuation is a program frozen in action: a single functional object containing
the state of a computation. When the object is evaluated, the stored computation
is restarted where it left off. In solving certain types of problems it can be
a great help to be able to save the state of a program and restart it later. In
multiprocessing, for example, a continuation conveniently represents a suspended
process. In nondeterministic search programs, a continuation can represent a node
in the search tree.
<P>

Continuations can be difficult to understand. This chapter approaches the
topic in two steps. The first part of the chapter looks at the use of continuations in
Scheme, which has built-in support for them. Once the behavior of continuations
# has been explained, the second part shows how to use macros to build continuations
in Common Lisp programs. Chapters 21--24 will all make use of the macros
defined here.
<P>

<div class="menuindex"><SCRIPT language=JavaScript src="onlisp20.js"></SCRIPT></div><noscript><BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="onlisp_21.html#SEC127">20.1 Scheme Continuations</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="onlisp_21.html#SEC128">20.2 Continuation-Passing Macros</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="onlisp_21.html#SEC129">20.3 Code-Walkers and CPS Conversion</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE></noscript>
<P>

<A NAME="Scheme Continuations"></A>
<HR SIZE="6">
<br><A NAME="SEC127"> </A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_21.html#SEC126"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_21.html#SEC128"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_21.html#SEC126"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_21.html#SEC126"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_22.html#SEC130"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_31.html#SEC168">Index</A>]</TD>
<TD> [<a href="#top">Page Top</a> / <a href="#bottom">Bottom</a>]</TD></TR></TABLE>
<A NAME="Scheme Continuations"></A>
<H2> 20.1 Scheme Continuations </H2>
<!--docid::SEC127::-->
<div class="info">URL="<a href="http://www.bookshelf.jp/cgi-bin/goto.cgi?file=onlisp&node=Scheme%2520Continuations">http://www.bookshelf.jp/cgi-bin/goto.cgi?file=onlisp&node=Scheme%2520Continuations</a>"<br>
<a href="http://www.bookshelf.jp/pukiwiki/pukiwiki.php?refer=MeadowMemo&cmd=read&page=onlisp%2FSchemeContinuations">comment</a>(none) to "onlisp/SchemeContinuations"</div><FORM METHOD="GET" ACTION="http://www.bookshelf.jp/cgi-bin/wwwsrch.cgi"><div class="info">search<INPUT TYPE=text NAME=WORD SIZE=30><INPUT TYPE=hidden NAME=dir VALUE=texi/onlisp><INPUT TYPE=hidden NAME=index VALUE=dirsearch CHECKED><INPUT TYPE=hidden NAME=langmode VALUE=en><INPUT TYPE=hidden NAME=target VALUE=all CHECKED><INPUT TYPE=hidden NAME=ANDOR VALUE=and CHECKED><INPUT TYPE=radio NAME=lisp VALUE=off CHECKED>Search<INPUT TYPE=radio NAME=lisp VALUE=on>Elisp<INPUT TYPE=submit VALUE="Search"></div></FORM>
<P>

One of the principal ways in which Scheme differs from Common Lisp is its
explicit support for continuations. This section shows how continuations work in
Scheme. (Figure 20.1 lists some other differences between Scheme and Common
Lisp.)
<P>

<OL>
<LI>
Scheme makes no distinction between what Common Lisp calls the
symbol-value and symbol-function of a symbol. In Scheme, a variable has a single value, which can be either a function or some other sort of
object. Thus there is no need for sharp-quote or funcall in Scheme. The
Common Lisp:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(let ((f #'(lambda (x) (1+ x))))
  (funcall f 2))
</pre></td></tr></table><P>

would be in Scheme:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(let ((f (lambda (x) (1+ x))))
  (f 2))
</pre></td></tr></table><P>

<LI>
Since Scheme has only one name-space, it doesn't need separate operators
(e.g. defun and setq) for assignments in each. Instead it has define, which
is roughly equivalent to defvar, and set!, which takes the place of setq.
Global variables must be created with define before they can be set with
set!.
<P>

<LI>
In Scheme, named functions are usually defined with define, which takes
the place of defun as well as defvar. The Common Lisp:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defun foo (x) (1+ x))
</pre></td></tr></table><P>

has two possible Scheme translations:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(define foo (lambda (x) (1+ x)))

(define (foo x) (1+ x))
</pre></td></tr></table><P>

<LI>
In Common Lisp, the arguments to a function are evaluated left-to-right. In
Scheme, the order of evaluation is deliberately unspecified. (And implementors
delight in surprising those who forget this.)
<P>

<LI>
Instead of t and nil, Scheme has #t and #f. The empty list, (), is true in
some implementations and false in others.
<P>

<LI>
The default clause in cond and case expressions has the key else in
Scheme, instead of t as in Common Lisp.
<P>

<LI>
Several built-in operators have different names: consp is pair?, null is
null?, mapcar is (almost) map, and so on. Ordinarily these should be obvious
from the context.
</OL>
<P>

<center>
 Figure 20.1: Some differences between Scheme and Common Lisp.
</center>
<A NAME="IDX114"></A>
<P>

A continuation is a function representing the future of a computation. Whenever an expression is evaluated, something is waiting for the value it will return.
For example, in
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(/ (- x 1) 2)
</pre></td></tr></table><P>

when (- x 1) is evaluated, the outer / expression is waiting for the value, and
something else is waiting for its value, and so on and so on, all the way back to
the toplevel--where print is waiting.
<P>

We can think of the continuation at any given time as a function of one
argument. If the previous expression were typed into the toplevel, then when the
subexpression (- x 1) was evaluated, the continuation would be:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(lambda (val) (/ val 2))
</pre></td></tr></table><P>

That is, the remainder of the computation could be duplicated by calling this
function on the return value. If instead the expression occurred in the following
context
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(define (f1 w)
  (let ((y (f2 w)))
    (if (integer? y) (list 'a y) 'b)))

(define (f2 x)
  (/ (- x 1) 2))
</pre></td></tr></table><P>

and f1 were called from the toplevel, then when (- x 1) was evaluated, the
continuation would be equivalent to
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(lambda (val)
  (let ((y (/ val 2)))
    (if (integer? y) (list 'a y) 'b)))
</pre></td></tr></table><P>

In Scheme, continuations are first-class objects, just like functions. You can
ask Scheme for the current continuation, and it will make you a function of one
argument representing the future of the computation. You can save this object for
as long as you like, and when you call it, it will restart the computation that was
taking place when it was created.
<P>

Continuations can be understood as a generalization of closures. A closure is
a function plus pointers to the lexical variables visible at the time it was created.
A continuation is a function plus a pointer to the whole stack pending at the time
it was created. When a continuation is evaluated, it returns a value using its own
copy of the stack, ignoring the current one. If a continuation is created at T 1 and
evaluated at T 2 , it will be evaluated with the stack that was pending at T 1 .
<P>

Scheme programs have access to the current continuation via the built-in
operator call-with-current-continuation (call/cc for short). When a
program calls call/cc on a function of one argument:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(call-with-current-continuation
 (lambda (cc)
   ...))
</pre></td></tr></table><P>

the function will be passed another function representing the current continuation.
By storing the value of cc somewhere, we save the state of the computation at the
point of the call/cc.
<P>

In this example, we append together a list whose last element is the value
returned by a call/cc expression:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>&#62; (define frozen)
FROZEN
&#62; (append '(the call/cc returned)
(list (call-with-current-continuation
(lambda (cc)
(set! frozen cc)
'a))))
(THE CALL/CC RETURNED A)
</pre></td></tr></table><P>

The call/cc returns a, but first saves the continuation in the global variable
frozen.
<P>

Calling frozen will restart the old computation at the point of the call/cc.
Whatever value we pass to frozen will be returned as the value of the call/cc:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>&#62; (frozen 'again)
(THE CALL/CC RETURNED AGAIN)
</pre></td></tr></table><P>

Continuations aren't used up by being evaluated. They can be called repeatedly,
just like any other functional object:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>&#62; (frozen 'thrice)
(THE CALL/CC RETURNED THRICE)
</pre></td></tr></table><P>

When we call a continuation within some other computation, we see more
clearly what it means to return back up the old stack:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>&#62; (+ 1 (frozen 'safely))
(THE CALL/CC RETURNED SAFELY)
</pre></td></tr></table><P>

Here, the pending + is ignored when frozen is called. The latter returns up
the stack that was pending at the time it was first created: through list, then
append, to the toplevel. If frozen returned a value like a normal function call,
the expression above would have yielded an error when + tried to add 1 to a list.
<P>

Continuations do not get unique copies of the stack. They may share variables
with other continuations, or with the computation currently in progress. In this
example, two continuations share the same stack:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>&#62; (define froz1)
FROZ1
&#62; (define froz2)
FROZ2
&#62; (let ((x 0))
(call-with-current-continuation
(lambda (cc)
(set! froz1 cc)
(set! froz2 cc)))
(set! x (1+ x))
x)
1
</pre></td></tr></table><P>

so calls to either will return successive integers:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>&#62; (froz2 ())
2
&#62; (froz1 ())
3
</pre></td></tr></table><P>

Since the value of the call/cc expression will be discarded, it doesn't matter
what argument we give to froz1 and froz2.
<P>

Now that we can store the state of a computation, what do we do with it?
Chapters 21--24 are devoted to applications which use continuations. Here we
will consider a simple example which conveys well the flavor of programming
with saved states: we have a set of trees, and we want to generate lists containing
one element from each tree, until we get a combination satisfying some condition.
<P>

Trees can be represented as nested lists. Page 70 described a way to represent
one kind of tree as a list. Here we use another, which allows interior nodes to have
(atomic) values, and any number of children. In this representation, an interior
node becomes a list; its car contains the value stored at the node, and its cdr
contains the representations of the node's children. For example, the two trees
shown in Figure 20.2 can be represented:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(define t1 '(a (b (d h)) (c e (f i) g)))

(define t2 '(1 (2 (3 6 7) 4 5)))
</pre></td></tr></table><P>

Figure 20.3 contains functions which do depth-first traversals on such trees. In
a real program we would want to do something with the nodes as we encountered
them. Here we just print them. The function dft, given for comparison, does an
ordinary depth-first traversal:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>&#62; (dft t1)
ABDHCEFIG()
</pre></td></tr></table><P>

<center>
 Figure 20.2: Two Trees.
</center>
<A NAME="IDX115"></A>
<P>

The function dft-node follows the same path through the tree, but deals out
nodes one at a time. When dft-node reaches a node, it follows the car of the
node, and pushes onto *saved* a continuation to explore the cdr.
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>&#62; (dft-node t1)
A
</pre></td></tr></table><P>

Calling restart continues the traversal, by popping the most recently saved
continuation and calling it.
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>&#62; (restart)
B
</pre></td></tr></table><P>

Eventually there will be no saved states left, a fact which restart signals by
returning done:
<TABLE><tr><td>&nbsp;</td><td class=example><pre>. . .
&#62; (restart)
G
&#62; (restart)
DONE
</pre></td></tr></table><P>

Finally, the function dft2 neatly packages up what we just did by hand:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>&#62; (dft2 t1)
ABDHCEFIG()
</pre></td></tr></table><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(define (dft tree)
  (cond ((null? tree) ())
	((not (pair? tree)) (write tree))
	(else (dft (car tree))
	      (dft (cdr tree)))))

(define *saved* ())

(define (dft-node tree)
  (cond ((null? tree) (restart))
	((not (pair? tree)) tree)
	(else (call-with-current-continuation
	       (lambda (cc)
		 (set! *saved*
		       (cons (lambda ()
			       (cc (dft-node (cdr tree))))
			     *saved*))
		 (dft-node (car tree)))))))

(define (restart)
  (if (null? *saved*)
      'done
    (let ((cont (car *saved*)))
      (set! *saved* (cdr *saved*))
      (cont))))

(define (dft2 tree)
  (set! *saved* ())
  (let ((node (dft-node tree)))
    (cond ((eq? node 'done) ())
	  (else (write node)
		(restart)))))
</pre></td></tr></table><P>

<center>
 Figure 20.3: Tree traversal using continuations.
</center>
<A NAME="IDX116"></A>
<P>

Notice that there is no explicit recursion or iteration in the definition of dft2: successive nodes are printed because the continuations invoked by restart always
return back through the same cond clause in dft-node.
<P>

This kind of program works like a mine. It digs the initial shaft by calling
dft-node. So long as the value returned is not done, the code following the call
to dft-node will call restart, which sends control back down the stack again.
This process continues until the return value signals that the mine is empty. Instead
of printing this value, dft2 returns #f. Search with continuations represents a
novel way of thinking about programs: put the right code in the stack, and get the
result by repeatedly returning up through it.
<P>

If we only want to traverse one tree at a time, as in dft2, then there is no
reason to bother using this technique. The advantage of dft-node is that we can
have several instances of it going at once. Suppose we have two trees, and we
want to generate, in depth-first order, the cross-product of their elements.
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>&#62; (set! *saved* ())
()
&#62; (let ((node1 (dft-node t1)))
(if (eq? node1 'done)
'done
(list node1 (dft-node t2))))
(A 1)
&#62; (restart)
(A 2)
. . .
&#62; (restart)
(B 1)
. . .
</pre></td></tr></table><P>

Using normal techniques, we would have had to take explicit steps to save our
place in the two trees. With continuations, the state of the two ongoing traversals
is maintained automatically. In a simple case like this one, saving our place in
the tree would not be so difficult. The trees are permanent data structures, so at
least we have some way of getting hold of "our place" in the tree. The great thing
about continuations is that they can just as easily save our place in the middle of
any computation, even if there are no permanent data structures associated with
it. The computation need not even have a finite number of states, so long as we
only want to restart a finite number of them.
<P>

As Chapter 24 will show, both of these considerations turn out to be important
in the implementation of Prolog. In Prolog programs, the "search trees" are not
real data structures, but are implicit in the way the program generates results. And
the trees are often infinite, in which case we cannot hope to search the whole of
one before searching the next; we have no choice but to save our place, one way
or another.
<P>

<A NAME="Continuation-Passing Macros"></A>
<HR SIZE="6">
<br><A NAME="SEC128"> </A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_21.html#SEC127"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_21.html#SEC129"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_21.html#SEC126"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_21.html#SEC126"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_22.html#SEC130"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_31.html#SEC168">Index</A>]</TD>
<TD> [<a href="#top">Page Top</a> / <a href="#bottom">Bottom</a>]</TD></TR></TABLE>
<A NAME="Continuation-Passing Macros"></A>
<H2> 20.2 Continuation-Passing Macros </H2>
<!--docid::SEC128::-->
<div class="info">URL="<a href="http://www.bookshelf.jp/cgi-bin/goto.cgi?file=onlisp&node=Continuation%2DPassing%2520Macros">http://www.bookshelf.jp/cgi-bin/goto.cgi?file=onlisp&node=Continuation%2DPassing%2520Macros</a>"<br>
<a href="http://www.bookshelf.jp/pukiwiki/pukiwiki.php?refer=MeadowMemo&cmd=read&page=onlisp%2FContinuation%2DPassingMacros">comment</a>(none) to "onlisp/Continuation-PassingMacros"</div><FORM METHOD="GET" ACTION="http://www.bookshelf.jp/cgi-bin/wwwsrch.cgi"><div class="info">search<INPUT TYPE=text NAME=WORD SIZE=30><INPUT TYPE=hidden NAME=dir VALUE=texi/onlisp><INPUT TYPE=hidden NAME=index VALUE=dirsearch CHECKED><INPUT TYPE=hidden NAME=langmode VALUE=en><INPUT TYPE=hidden NAME=target VALUE=all CHECKED><INPUT TYPE=hidden NAME=ANDOR VALUE=and CHECKED><INPUT TYPE=radio NAME=lisp VALUE=off CHECKED>Search<INPUT TYPE=radio NAME=lisp VALUE=on>Elisp<INPUT TYPE=submit VALUE="Search"></div></FORM>
<P>

Common Lisp doesn't provide call/cc, but with a little extra effort we can do
the same things as we can in Scheme. This section shows how to use macros to
build continuations in Common Lisp programs. Scheme continuations gave us
two things:
<OL>
<LI>
The bindings of all variables at the time the continuation was made.
<LI>
The state of the computation--what was going to happen from then on.
</OL>
<P>

In a lexically scoped Lisp, closures give us the first of these. It turns out that we can
also use closures to maintain the second, by storing the state of the computation
in variable bindings as well.
<P>

The macros shown in Figure 20.4 make it possible to do function calls while
preserving continuations. These macros replace the built-in Common Lisp forms
for defining functions, calling them, and returning values.
<P>

Functions which want to use continuations (or call functions which do) should
be defined with =defun instead of defun. The syntax of =defun is the same as
# that of defun, but its effect is subtly different. Instead of defining just a function,
=defun defines a function and a macro which expands into a call to it. (The macro
must be defined first, in case the function calls itself.) The function will have the
body that was passed to =defun, but will have an additional parameter, *cont*,
consed onto its parameter list. In the expansion of the macro, this function will
receive *cont* along with its other arguments. So
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(=defun add1 (x) (=values (1+ x)))
</pre></td></tr></table><P>

macroexpands into
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(progn (defmacro add1 (x)
	 `(=add1 *cont* ,x))
       (defun =add1 (*cont* x)
	 (=values (1+ x))))
</pre></td></tr></table><P>

When we call add1, we are actually calling not a function but a
macro. The macro expands into a function call,<A NAME="DOCF32" HREF="onlisp_fot.html#FOOT32">(32)</A> but with one extra parameter: *cont*. So
the current value of *cont* is always passed implicitly in a call to
an operator defined with =defun.
<P>

What is *cont* for? It will be bound to the current continuation. The
definition of =values shows how this continuation will be used. Any function
defined using =defun must return with =values, or call some other function
which does so. The syntax of =values is the same as that of the Common Lisp
form values. It can return multiple values if there is an =bind with the same
number of arguments waiting for them, but can't return multiple values to the
toplevel. #
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(setq *cont* #'identity)

(defmacro =lambda (parms &#38;body body)
  `#'(lambda (*cont* ,&#64;parms) ,&#64;body))

(defmacro =defun (name parms &#38;body body)
  (let ((f (intern (concatenate 'string
				"=" (symbol-name name)))))
    `(progn
       (defmacro ,name ,parms
	 `(,',f *cont* ,,&#64;parms))
       (defun ,f (*cont* ,&#64;parms) ,&#64;body))))

(defmacro =bind (parms expr &#38;body body)
  `(let ((*cont* #'(lambda ,parms ,&#64;body))) ,expr))

(defmacro =values (&#38;rest retvals)
  `(funcall *cont* ,&#64;retvals))

(defmacro =funcall (fn &#38;rest args)
  `(funcall ,fn *cont* ,&#64;args))

(defmacro =apply (fn &#38;rest args)
  `(apply ,fn *cont* ,&#64;args))
</pre></td></tr></table><P>

<center>
 Figure 20.4: Continuation-passing macros.
</center>
<A NAME="IDX117"></A>
<P>

The parameter *cont* tells a function defined with =defun what to do with
its return value. When =values is macroexpanded it will capture *cont*, and
use it to simulate returning from the function. The expression
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>&#62; (=values (1+ n))
</pre></td></tr></table><P>

expands into
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(funcall *cont* (1+ n))
</pre></td></tr></table><P>

At the toplevel, the value of *cont* is identity, which just returns whatever is
passed to it. When we call (add1 2) from the toplevel, the call gets macroexpanded into the equivalent of
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(funcall #'(lambda (*cont* n) (=values (1+ n))) *cont* 2)
</pre></td></tr></table><P>

The reference to *cont* will in this case get the global binding. The =values
expression will thus macroexpand into the equivalent of:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(funcall #'identity (1+ n))
</pre></td></tr></table><P>

which just adds 1 to n and returns the result.
<P>

In functions like add1, we go through all this trouble just to simulate what
Lisp function call and return do anyway:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>&#62; (=defun bar (x)
(=values (list 'a (add1 x))))
BAR
&#62; (bar 5)
(A 6)
</pre></td></tr></table><P>

The point is, we have now brought function call and return under our own control,
and can do other things if we wish.
<P>

It is by manipulating *cont* that we will get the effect of continuations.
Although *cont* has a global value, this will rarely be the one used: *cont* will
nearly always be a parameter, captured by =values and the macros defined by
=defun. Within the body of add1, for example, *cont* is a parameter and not the
global variable. This distinction is important because these macros wouldn't work
if *cont* were not a local variable. That's why *cont* is given its initial value
in a setq instead of a defvar: the latter would also proclaim it to be special.
<P>

The third macro in Figure 20.4, =bind, is intended to be used in the same way
as multiple-value-bind. It takes a list of parameters, an expression, and a
body of code: the parameters are bound to the values returned by the expression,
and the code body is evaluated with those bindings. This macro should be used
whenever additional expressions have to be evaluated after calling a function
defined with =defun.
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>&#62; (=defun message ()
(=values 'hello 'there))
MESSAGE
</pre></td></tr></table><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>&#62; (=defun baz ()
(=bind (m n) (message)
(=values (list m n))))
BAZ
&#62; (baz)
(HELLO THERE)
</pre></td></tr></table><P>

Notice that the expansion of an =bind creates a new variable called *cont*. The
body of baz macroexpands into:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(let ((*cont* #'(lambda (m n)
		  (=values (list m n)))))
  (message))
</pre></td></tr></table><P>

which in turn becomes:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(let ((*cont* #'(lambda (m n)
		  (funcall *cont* (list m n)))))
  (=message *cont*))
</pre></td></tr></table><P>

The new value of *cont* is the body of the =bind expression, so when message
"returns" by funcalling *cont*, the result will be to evaluate the body of code.
However (and this is the key point), within the body of the =bind:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>#'
(lambda (m n)
    (funcall *cont* (list m n)))
</pre></td></tr></table><P>

the *cont* that was passed as an argument to =baz is still visible, so when the
body of code in turn evaluates an =values, it will be able to return to the original
calling function. The closures are knitted together: each binding of *cont* is a
closure containing the previous binding of *cont*, forming a chain which leads
all the way back up to the global value.
<P>

We can see the same phenomenon on a smaller scale here:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>&#62; (let ((f #'identity))
(let ((g #'(lambda (x) (funcall f (list 'a x)))))
#'(lambda (x) (funcall g (list 'b x)))))
#&#60;Interpreted-Function BF6326&#62;
&#62; (funcall * 2)
(A (B 2))
</pre></td></tr></table><P>

This example creates a function which is a closure containing a reference to g,
which is itself a closure containing a reference to f. Similar chains of closures
were built by the network compiler on page 80.
<P>

<OL>
<LI>The parameter list of a function defined with =defun must consist solely
of parameter names.
<P>

<LI>Functions which make use of continuations, or call other functions which
do, must be defined with =lambda or =defun.
<P>

<LI>Such functions must terminate either by returning values with =values, or
by calling another function which obeys this restriction.
<P>

<LI>If an =bind, =values, =apply, or =funcall expression occurs in a segment of code, it must be a tail call. Any code to be evaluated after an =bind
should be put in its body. So if we want to have several =binds one after
another, they must be nested:
</OL>
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(=defun foo (x)
	(=bind (y) (bar x)
	       (format t "Ho ")
	       (=bind (z) (baz x)
		      (format t "Hum.")
		      (=values x y z))))
</pre></td></tr></table><P>

<center>
 Figure 20.5: Restrictions on continuation-passing macros.
</center>
<A NAME="IDX118"></A>
<P>

The remaining macros, =apply and =funcall, are for use with functions
defined by =lambda. Note that "functions" defined with =defun, because they
are actually macros, cannot be given as arguments to apply or funcall. The
way around this problem is analogous to the trick mentioned on page 110. It is to
package up the call inside another =lambda:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>&#62; (=defun add1 (x)
(=values (1+ x)))
ADD1
&#62; (let ((fn (=lambda (n) (add1 n))))
(=bind (y) (=funcall fn 9)
(format nil "9 + 1 = ~A" y)))
"9 + 1 = 10"
</pre></td></tr></table><P>

Figure 20.5 summarizes all the restrictions imposed by the continuation-passing macros. Functions which neither save continuations, nor call other functions which do, need not use these special macros. Built-in functions like list,
for example, are exempt.
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defun dft (tree)
  (cond ((null tree) nil)
	((atom tree) (princ tree))
	(t (dft (car tree))
	   (dft (cdr tree)))))

(setq *saved* nil)

(=defun dft-node (tree)
	(cond ((null tree) (restart))
	      ((atom tree) (=values tree))
	      (t (push #'(lambda () (dft-node (cdr tree)))
		       *saved*)
		 (dft-node (car tree)))))

(=defun restart ()
	(if *saved*
	    (funcall (pop *saved*))
	  (=values 'done)))

(=defun dft2 (tree)
	(setq *saved* nil)
	(=bind (node) (dft-node tree)
	       (cond ((eq node 'done) (=values nil))
		     (t (princ node)
			(restart)))))
</pre></td></tr></table><P>

<center>
 Figure 20.6: Tree traversal using continuation-passing macros.
</center>
<A NAME="IDX119"></A>
<P>

Figure 20.6 contains the code from Figure 20.3, translated from Scheme into
Common Lisp, and using the continuation-passing macros instead of Scheme
continuations. With the same example tree, dft2 works just as before:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>&#62; (setq t1 '(a (b (d h)) (c e (f i) g))
t2 '(1 (2 (3 6 7) 4 5)))
(1 (2 (3 6 7) 4 5))
&#62; (dft2 t1)
ABDHCEFIG
NIL
</pre></td></tr></table><P>

Saving states of multiple traversals also works as in Scheme, though the example
becomes a bit longer:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>&#62; (=bind (node1) (dft-node t1)
(if (eq node1 'done)
'done
(=bind (node2) (dft-node t2)
(list node1 node2))))
(A 1)
&#62; (restart)
(A 2)
. . .
&#62; (restart)
(B 1)
. . .
</pre></td></tr></table><P>

By knitting together a chain of lexical closures, Common Lisp programs can
build their own continuations. Fortunately, the closures are knitted together by
the macros in the sweatshop of Figure 20.4, and the user can have the finished
garment without giving a thought to its origins.
<P>

Chapters 21--24 all rely on continuations in some way. These chapters will
show that continuations are an abstraction of unusual power. They may not be
overly fast, especially when implemented on top of the language as macros, but
the abstractions we can build upon them make certain programs much faster to
write, and there is a place for that kind of speed too.
<P>

<A NAME="Code-Walkers and CPS Conversion"></A>
<HR SIZE="6">
<br><A NAME="SEC129"> </A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_21.html#SEC128"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_22.html#SEC130"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_21.html#SEC126"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_21.html#SEC126"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_22.html#SEC130"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_31.html#SEC168">Index</A>]</TD>
<TD> [<a href="#top">Page Top</a> / <a href="#bottom">Bottom</a>]</TD></TR></TABLE>
<A NAME="Code-Walkers and CPS Conversion"></A>
<H2> 20.3 Code-Walkers and CPS Conversion </H2>
<!--docid::SEC129::-->
<div class="info">URL="<a href="http://www.bookshelf.jp/cgi-bin/goto.cgi?file=onlisp&node=Code%2DWalkers%2520and%2520CPS%2520Conversion">http://www.bookshelf.jp/cgi-bin/goto.cgi?file=onlisp&node=Code%2DWalkers%2520and%2520CPS%2520Conversion</a>"<br>
<a href="http://www.bookshelf.jp/pukiwiki/pukiwiki.php?refer=MeadowMemo&cmd=read&page=onlisp%2FCode%2DWalkersandCPSConversion">comment</a>(none) to "onlisp/Code-WalkersandCPSConversion"</div><FORM METHOD="GET" ACTION="http://www.bookshelf.jp/cgi-bin/wwwsrch.cgi"><div class="info">search<INPUT TYPE=text NAME=WORD SIZE=30><INPUT TYPE=hidden NAME=dir VALUE=texi/onlisp><INPUT TYPE=hidden NAME=index VALUE=dirsearch CHECKED><INPUT TYPE=hidden NAME=langmode VALUE=en><INPUT TYPE=hidden NAME=target VALUE=all CHECKED><INPUT TYPE=hidden NAME=ANDOR VALUE=and CHECKED><INPUT TYPE=radio NAME=lisp VALUE=off CHECKED>Search<INPUT TYPE=radio NAME=lisp VALUE=on>Elisp<INPUT TYPE=submit VALUE="Search"></div></FORM>
<P>

The macros described in the previous section represent a compromise. They give
us the power of continuations, but only if we write our programs in a certain way.
Rule 4 in Figure 20.5 means that we always have to write
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(=bind (x) (fn y)
       (list 'a x))
</pre></td></tr></table><P>

rather than
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(list 'a				; wrong
      (=bind (x) (fn y) x))
</pre></td></tr></table><P>

A true call/cc imposes no such restrictions on the programmer. A call/cc can
grab the continuation at any point in a program of any shape. We could implement
an operator with the full power of call/cc, but it would be a lot more work. This
section outlines how it could be done.
<P>

A Lisp program can be transformed into a form called "continuation-passing
style." Programs which have undergone complete CPS conversion are impossible
to read, but one can grasp the spirit of this process by looking at code which has
been partially transformed. The following function to reverse lists: #
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defun rev (x)
  (if (null x)
      nil
    (append (rev (cdr x)) (list (car x)))))
</pre></td></tr></table><P>

yields an equivalent continuation-passing version:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defun rev2 (x)
  (revc x #'identity))

(defun revc (x k)
  (if (null x)
      (funcall k nil)
    (revc (cdr x)
	  #'(lambda (w)
	      (funcall k (append w (list (car x))))))))
</pre></td></tr></table><P>

In the continuation-passing style, functions get an additional parameter (here k)
whose value will be the continuation. The continuation is a closure representing
what should be done with the current value of the function. On the first recursion,
the continuation is identity; what should be done is that the function should
just return its current value. On the second recursion, the continuation will be
equivalent to:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>#'
(lambda (w)
    (identity (append w (list (car x)))))
</pre></td></tr></table><P>

which says that what should be done is to append the car of the list to the current
value, and return it.
<P>

Once you can do CPS conversion, it is easy to write call/cc. In a program
which has undergone CPS conversion, the entire current continuation is always
present, and call/cc can be implemented as a simple macro which calls some
function with it as an argument.
<P>

To do CPS conversion we need a code-walker, a program that traverses the
trees representing the source code of a program. Writing a code-walker for
Common Lisp is a serious undertaking. To be useful, a code-walker has to do #
more than simply traverse expressions. It also has to know a fair amount about
what the expressions mean. A code-walker can't just think in terms of symbols,
for example. A symbol could represent, among other things, itself, a function, a
variable, a block name, or a tag for go. The code-walker has to use the context to
distinguish one kind of symbol from another, and act accordingly.
<P>

Since writing a code-walker would be beyond the scope of this book, the
macros described in this chapter are the most practical alternative. The macros
in this chapter split the work of building continuations with the user. If the user
writes programs in something sufficiently close to CPS, the macros can do the
rest. That's what rule 4 really amounts to: if everything following an =bind
expression is within its body, then between the value of *cont* and the code
in the body of the =bind, the program has enough information to construct the
current continuation.
<P>

The =bind macro is deliberately written to make this style of programming
feel natural. In practice the restrictions imposed by the continuation-passing
macros are bearable.
<P>

<A NAME="Multiple Processes"></A>
<HR SIZE="6">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_21.html#SEC126"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_22.html#SEC130"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="onlisp_31.html#SEC168">Index</A>]</TD>
<TD> [<a href="#top">Page Top</a> / <a href="#bottom">Bottom</a>]</TD></TR></TABLE>
<a name="bottom"> </a>
<script type="text/javascript" src="style2.js"></script>
<div class="footer">
    <br>
mail:<img src="http://www.bookshelf.jp/img/mail.jpg"><br>

<br>
<script src="http://trackfeed.com/usr/2d246b4e25.js"></script>
</div>

</BODY>

</HTML>
