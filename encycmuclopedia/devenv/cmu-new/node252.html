<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.2//EN">
<!--Converted with LaTeX2HTML 96.1-h (September 30, 1996) by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds -->
<HTML>
<HEAD>
<TITLE>9.2.2 Tagged Data</TITLE>
<META NAME="description" CONTENT="9.2.2 Tagged Data">
<META NAME="keywords" CONTENT="cmu-new">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<LINK REL=STYLESHEET HREF="cmu-new.css">
</HEAD>
<BODY LANG="EN" >
 <A NAME="tex2html3891" HREF="node253.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="next_motif.gif"></A> <A NAME="tex2html3889" HREF="node250.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="up_motif.gif"></A> <A NAME="tex2html3883" HREF="node251.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="previous_motif.gif"></A> <A NAME="tex2html3893" HREF="node1.html"><IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="contents" SRC="contents_motif.gif"></A> <A NAME="tex2html3894" HREF="node267.html"><IMG WIDTH=43 HEIGHT=24 ALIGN=BOTTOM ALT="index" SRC="index_motif.gif"></A> <BR>
<B> Next:</B> <A NAME="tex2html3892" HREF="node253.html">9.2.3 Making Your Own </A>
<B>Up:</B> <A NAME="tex2html3890" HREF="node250.html">9.2 The WIRE Package</A>
<B> Previous:</B> <A NAME="tex2html3884" HREF="node251.html">9.2.1 Untagged Data</A>
<BR> <P>
<H2><A NAME="SECTION001022000000000000000">9.2.2 Tagged Data</A></H2>
<P>
When using these routines, the system automatically transmits and interprets
the tags for you, so both ends can figure out what kind of data transfers
occur.  Sending tagged data allows a greater variety of data types: integers
inclusively less than 32 bits in length, symbols, lists, and <i>remote-objects</i>
(see section&nbsp;<A HREF="node248.html#remoteobjs">9.1.3</A>).  The system sends symbols as two strings, the
package name and the symbol name, and if the package doesn't exist remotely,
the remote process signals an error.  The system ignores other slots of
symbols.  Lists may be any tree of the above valid data types.  To send other
data types you must represent them in terms of these supported types.  For
example, you could use <tt>prin1-to-string</tt> locally, send the string, and use
<tt>read-from-string</tt> remotely.
<P>
<b>[Function]</b><BR> 
<tt> wire: wire-output-object</tt> <em> <i>wire</i> <i>object</i> <i>&amp;optional</i> <i>cache-it</i></em><BR> 
  <tt>wire:wire-get-object</tt> <EM></EM><i>wire</i><BR>
<P>
  The function <tt>wire-output-object</tt> sends <i>object</i> over
  <i>wire</i> preceded by a tag indicating its type.
<P>
  If <i>cache-it</i> is non-<i>nil</i>, this function only sends <i>object</i>
  the first time it gets <i>object</i>.  Each end of the wire
  associates a token with <i>object</i>, similar to remote-objects,
  allowing you to send the object more efficiently on successive
  transmissions.  <i>cache-it</i> defaults to <i>t</i> for symbols and
  <i>nil</i> for other types.  Since the RPC level requires function
  names, a high-level protocol based on a set of function calls saves
  time in sending the functions' names repeatedly.
<P>
  The function <tt>wire-get-object</tt> reads the results of
  <tt>wire-output-object</tt> and returns that object.
<P>
<BR> <HR>
<P><ADDRESS>
<I>Raymond Toy <BR>
Mon Sep 22 16:34:07 EDT 1997</I>
</ADDRESS>
</BODY>
</HTML>
